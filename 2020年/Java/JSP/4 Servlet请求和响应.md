# 4 `servlet`请求和响应

​	`servlet`的存在就是要为客户服务。`servlet`的任务是得到一个客户的请求，再发回一个响应。请求携带了一些重要的数据，你的`servlet`代码必须知道怎么找到和使用这个请求。响应也携带着一些信息，浏览器需要这些信息来显示一个页面或下载数据，你的`servlet`代码必须知道怎么知道怎么发送这些信息，也可以把请求传递给其他页面、`servlet`或`JSP`。

## 1 servlet的生命周期

| Web容器 |                               | servlet类      | servlet对象                                                  |
| ------- | ----------------------------- | -------------- | ------------------------------------------------------------ |
|         | 加载类                        | AServlet.class |                                                              |
|         | 实例化servlet（构造函数运行） |                | servlet类的无参构造函数运行，不要自己写构造函数,只需使用编译器提供的默认构造函数即可 |
|         | init()                        |                | 在servlet一生中只调用一次，而且在容器调用service()之前必须完成 |
|         | service()                     |                | servlet的一生主要都在这里度过，用来处理客户请求              |
|         | destroy()                     |                | 容器调用这个方法，从而在servlet被杀死之前有机会清理资源。destroy()也只会调用一次。 |

## 1.1 servlet被初始化后的使用流程：

1. 用户点击一个链接，链接的一个URL指向一个servlet；
2. 容器看出这个请求指向一个servlet，所以容器创建两个对象：HttpServletRequest、HttpServletResponse；
3. 容器根据请求中的URL找到正确的servlet，为这个请求创建或分配一个线程，并调用servlet的service()方法，把请求和响应对象作为参数传递给它；
4. service()方法根据客户发出的HTTP 方法（Get/Post等），确定要调用那个servlet方法；
5. servlet使用响应对象将响应写给客户。响应通过容器返回；
6. service()方法结束，所以线程要么撤销，要么返回到容器管理的一个线程池。请求和响应对象引用已经出了作用域，所以这些对象也没有意义，可以垃圾回收。客户得到响应。

## 1.2 生命周期中的三大重要时刻：

| 方法             | 何时调用                                                     | 作用                                                         | 是否覆盖                                                     |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| init()           | servlet实例被创建之后，并在servlet能为客户请求提供服务之前，容器要对servlet调用init() | 使你在servlet处理客户请求之前有机会对其初始化                | 可以覆盖。如果有初始化代码(如得到一个数据库连接)，就要覆盖该方法 |
| service()        | 当第一个客户请求到来时，容器会开始一个新线程，或从线程池分配一个线程,并调用servlet的service()方法 | 这个方法会查看请求，确定HTTP方法，并在servlet上调用对应的方法，如doGet()、doPost()等 | 不应该覆盖该方法。应该覆盖doGet()或doPost()方法，而由HttpServlet中的service()实例来考虑该调用哪一个方法 |
| doGet()/doPost() | service()方法根据请求的Http方法来调用doGet()或doPost()       | 负责Web应用想要做的工作                                      | 至少要覆盖其中之一                                           |

容器运行多个线程来处理对一个servlet的多个请求。

### 1.3 加载和初始化

容器启动时，它会寻找已经部署的Web应用，然后开始搜索servlet类文件。这只是第一步。加载类是第二步，这可能在容器启动时发生，也可能在第一个客户使用时进行。无论是什么时候进行加载，init()总是在第一个service()调用之前完成。

### 1.4 ServletConfig和ServletContext

ServletConfig对象：

- 每个servlet有一个ServletConfig对象；
- 用于向servlet传递部署时信息，例如数据库或企业bean的查找名，而又不想把这个信息硬编码到servlet中；
- 用于访问ServletContext；
- 参数在部署描述文件中配置；
- 一旦servlet被部署并运行，ServletConfig参数就不能再改变；

ServletContext对象：

- 每个Web应用有一个ServletContext；
- 用于访问Web应用参数，也在部署描述文件中配置；
- 相当于应用中的一个公告栏，可以在这里放消息（属性），应用的其他部分可以访问这些消息；
- 用于得到服务器信息，包括容器的名字和版本，以及所支持的API的版本等；

## 2 HttpServletRequest

- POST请求有一个体；Get请求没有，不过GET请求可以把请求参数追加到请求URL的后面。
- GET请求本质上讲是幂等的。它们应当能多次运行而不会对服务器产生任何副作用。GET请求不应该修改服务器上的任何东西，但也可以写一个非幂等的doGet()方法。
- POST本质上讲不是幂等的，所以要由用户来适当的设计和编写代码，如果客户错误地把一个请求发送了两次，也能正确地加以处理。
- 如果HTML表单没有明确的指出"method=POST"，请求就会作为一个GET请求发送。
- 可以用getParameter("name")方法从请求得到参数，返回值总是一个String。
- 如果对应一个给定的参数名有多个参数值，要使用getParameterValues("name")方法来返回一个String数组。
- 从请求对象还可以得到其他东西，包括首部、cookie、会话、查询串和输入流。

## 3 HttpServletResponse

- 对响应对象调用的最常用的方法是setContentType()和getWriter();
- 利用getWriter()方法可以完成字符I/O，向流写入HTML或其他内容；
- 还可以使用响应来设置首部、发送错误，以及增加cookie；
- 在响应上调用getOutputStream()方法得到二进制流；
- setContentType()方法告诉浏览器如何处理随响应到来的数据。常见的内容类型为”text/html“、"application/pdf"和"image/jpeg"；
- 