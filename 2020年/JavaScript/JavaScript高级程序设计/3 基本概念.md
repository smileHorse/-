# 1 语法

- `ECMAScript`中的一切都区分大小写。

- 严格模式

  `ECMAScript 5` 引入了严格模式（ strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模型。在严格模式下， `ECMAScript 3` 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：

  ~~~javascript
  "use strict";
  ~~~


  这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（`pragma`），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为不破坏 `ECMAScript 3` 语法而特意选定的语法。在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：

  ~~~javascript
  function doSomething(){
      "use strict";
      //函数体
  }
  ~~~

  严格模式下， JavaScript 的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支持严格模式的浏览器包括 IE 10+、 Firefox 4+、 Safari 5.1+、 Opera 12+和 Chrome。  

- `ECMAScript` 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾。

  虽然语句结尾的分号不是必需的，但我们建议任何时候都不要省略它。因为加上这个分号可以避免很多错误（例如不完整的输入），开发人员也可以放心地通过删除多余的空格来压缩 `ECMAScript` 代码（代码行结尾处没有分号会导致压缩错误）。另外，加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。  

# 2 关键字和保留字

​	`ECMA-262` 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是 `ECMAScript`的全部关键字（带*号上标的是第 5 版新增的关键字）：*

~~~
break 		do 			instanceof 		typeof
case 		else 		new 			var
catch 		finally 	return 			void
continue 	for 		switch 			while
debugger* 	function 	this 			with
default 	if 			throw
delete 		in 			try
~~~

​	`ECMA-262` 还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。以下是 `ECMA-262` 第 3 版定义的全部保留字：

~~~
abstract 		enum 			int 			short
boolean 		export 			interface 		static
byte 			extends 		long 			super
char 			final 			native 			synchronized
class 			float 			package 		throws
const 			goto 			private 		transient
debugger 		implements 		protected 		volatile
double 			import 			public  
~~~

​	第 5 版把在非严格模式下运行时的保留字缩减为下列这些：

~~~
class 		enum 		extends 		super
const 		export 		import
~~~

​	在严格模式下，第 5 版还对以下保留字施加了限制：

~~~
implements 		package 		public
interface 		private 		static
let 			protected 		yield
~~~

​	注意， let 和 yield 是第 5 版新增的保留字；其他保留字都是第 3 版定义的。为了最大程度地保证兼容性，建议读者将第 3 版定义的保留字外加 let 和 yield 作为编程时的参考。
​	在实现 `ECMAScript 3` 的 JavaScript 引擎中使用关键字作标识符，会导致“Identifier Expected”错误。而使用保留字作标识符可能会也可能不会导致相同的错误，具体取决于特定的引擎。
​	第 5 版对使用关键字和保留字的规则进行了少许修改。关键字和保留字虽然仍然不能作为标识符使用，但现在可以用作对象的属性名。一般来说，最好都不要使用关键字和保留字作为标识符和属性名，以便与将来的 `ECMAScript` 版本兼容。
​	除了上面列出的保留字和关键字， `ECMA-262` 第 5 版对 `eval`和 arguments 还施加了限制。在严
格模式下，这两个名字也不能作为标识符或属性名，否则会抛出错误。  

# 3 变量

​	`ECMAScript`的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。  

​	用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁。不过，可以像下面这样省略 var 操作符，从而创建一个全局变量：  

~~~javascript
function test(){
	message = "hi"; // 全局变量
}
test();
alert(message); // "hi"
~~~

​	这个例子省略了 var 操作符，因而 message 就成了全局变量。这样，只要调用过一次 test()函数，这个变量就有了定义，就可以在函数外部的任何地方被访问到。  

​	虽然省略 var 操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护，而且如果有意地忽略了 var 操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下会导致抛出 `ReferenceError` 错误。  

# 4 数据类型

​	`ECMAScript` 中有 5 种简单数据类型（也称为基本数据类型）： Undefined、 Null、 Boolean、 Number和 String。 还有 1 种复杂数据类型——Object， Object 本质上是由一组无序的名值对组成的。 `ECMAScript`不支持任何创建自定义类型的机制，而所有值最终都将是上述 6 种数据类型之一。乍一看，好像只有 6种数据类型不足以表示所有数据；但是，由于 `ECMAScript` 数据类型具有动态性，因此的确没有再定义其他数据类型的必要了。  

## 4.1 `typeof`操作符

​	`typeof`用来检测给定变量的数据类型。对一个值使用`typeof`操作符可能返回下列某个字符串：

- undefined：如果这个值未定义；
- boolean：如果这个值是布尔值；
- string：如果这个值是字符串；
- number：如果这个值是数值；
- object：如果这个值是对象或null；（因为特殊值null被认为是一个空的对象引用）
- function：如果这个值是函数；

​	从技术角度讲，函数在 `ECMAScript` 中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 `typeof` 操作符来区分函数和其他对象是有必要的。  

​	`typeof` 操作符的操作数可以是变量（ message），也可以是数值字面量。注意，`typeof` 是一个操作符而不是函数，因此圆括号尽管可以使用，但不是必需的。  

## 4.2 Undefined类型

​	Undefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined。

​	一般而言，不存在需要显式地把一个变量设置为 undefined 值的情况。字面值undefined 的主要目的是用于比较。

​	不过，包含 undefined 值的变量与尚未定义的变量还是不一样的。例如：

~~~javascript
var message; // 这个变量声明之后默认取得了 undefined 值
// 下面这个变量并没有声明
// var age
alert(message); // "undefined"
alert(age); // 产生错误
~~~

​	对于尚未声明过的变量，只能执行一项操作，即使用 `typeof` 操作符检测其数据类型（对未经声明的变量调用 delete 不会导致错误，但这样做没什么实际意义，而且在严格模式下确实会导致错误）。
​	然而，令人困惑的是：对未初始化的变量执行 `typeof` 操作符会返回 undefined 值，而对未声明的变量执行 `typeof` 操作符同样也会返回 undefined 值。  

~~~javascript
var message; // 这个变量声明之后默认取得了 undefined 值
// 下面这个变量并没有声明
// var age
alert(typeof message); // "undefined"
alert(typeof age); // "undefined"
~~~

​	结果表明，对未初始化和未声明的变量执行 `typeof` 操作符都返回了 undefined 值；这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。
​	即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 `typeof` 操作符返回"undefined"值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。  

## 4.3 Null类型

​	Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看， null 值表示一个空对象指针，而这也正是使用 `typeof` 操作符检测 null 值时会返回"object"的原因。

​	如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子所示：

~~~javascript
if (car != null){
	// 对 car 对象执行某些操作
}
~~~

​	实际上， undefined 值是派生自 null 值的，因此 `ECMA-262` 规定对它们的相等性测试要返回 true：

~~~javascript
alert(null == undefined); //true
~~~

​	这里，位于 null 和 undefined 之间的相等操作符（ ==）总是返回 true，不过要注意的是，这个
操作符出于比较的目的会转换其操作数。
​	尽管 null 和 undefined 有这样的关系，但它们的用途完全不同。如前所述，无论在什么情况下都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。

## 4.4 Boolean类型

​	Boolean 类型是 `ECMAScript` 中使用得最多的一种类型，该类型只有两个字面值： true 和 false。这两个值与数字值不是一回事，因此 true 不一定等于 1，而 false 也不一定等于 0。需要注意的是， Boolean 类型的字面值 true 和 false 是区分大小写的。也就是说， True 和 False（以及其他的混合大小写形式）都不是 Boolean 值，只是标识符。
​	虽然 Boolean 类型的字面值只有两个，但 `ECMAScript` 中所有类型的值都有与这两个 Boolean 值等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()，如下例所示：

~~~javascript
var message = "Hello world!";
var messageAsBoolean = Boolean(message);  
~~~

​	可以对任何数据类型的值调用 Boolean()函数，而且总会返回一个 Boolean 值。至于返回的这个值是 true 还是 false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对应的转换规则：

| 数据类型  | 转换为true的值               | 转换为false的值 |
| --------- | ---------------------------- | --------------- |
| Boolean   | true                         | false           |
| String    | 任何非空字符串               | 空字符串        |
| Number    | 任何非零数字值（包括无穷大） | 0和`NaN`        |
| Object    | 任何对象                     | null            |
| Undefined | 不适用                       | undefined       |

## 4.5 Number类型

​	Number 类型应该是 `ECMAScript` 中最令人关注的数据类型了，这种类型使用`IEEE754` 格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。为支持各种数值类型， `ECMA-262` 定义了不同的数值字面量格式。

​	最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输入：

~~~javascript
var intNum = 55; // 整数
~~~

​	除了以十进制表示外，整数还可以通过八进制（以 8 为基数）或十六进制（以 16 为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（ 0），然后是八进制数字序列（ 0～ 7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。请看下面的例子：

~~~javascript
var octalNum1 = 070; // 八进制的 56
var octalNum2 = 079; // 无效的八进制数值——解析为 79
var octalNum3 = 08; // 无效的八进制数值——解析为 8
~~~

​	八进制字面量在严格模式下是无效的，会导致支持的 JavaScript 引擎抛出错误。
​	十六进制字面值的前两位必须是 `0x`，后跟任何十六进制数字（ 0～ 9 及 A～ F）。其中，字母 A～ F可以大写，也可以小写。如下面的例子所示：

~~~javascript
var hexNum1 = 0xA; // 十六进制的 10
var hexNum2 = 0x1f; // 十六进制的 31
~~~

​	在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。  

​	鉴于 JavaScript 中保存数值的方式，可以保存正零（ +0）和负零（ 0）。正零和负零被认为相等，但为了读者更好地理解上下文，这里特别做此说明。

### 4.5.1 浮点数值

​	由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 `ECMAScript` 会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样地，如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数，如下面的例子所示：

~~~javascript
var floatNum1 = 1.; // 小数点后面没有数字——解析为 1
var floatNum2 = 10.0; // 整数——解析为 10
~~~

​	对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示。  

​	在默认情况下， `ECMASctipt` 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值（例如， 0.0000003 会被转换成 `3e-7`）。
​	浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如， 0.1 加 0.2的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。因此，永远不要测试某个特定的浮点数值。  

### 4.5.2 数值范围

​	由于内存的限制， `ECMAScript` 并不能保存世界上所有的数值。 `ECMAScript` 能够表示的最小数值保存在 `Number.MIN_VALUE` 中——在大多数浏览器中，这个值是 `5e-324`；能够表示的最大数值保存在`Number.MAX_VALUE` 中——在大多数浏览器中，这个值是 `1.7976931348623157e+308`。如果某次计算的结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转换成 Infinity（正无穷）。
​	如上所述，如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，因为 Infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用 `isFinite()`函数。这个函数在参数位于最小与最大数值之间时会返回 true，如下面的例子所示：

~~~javascript
var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert(isFinite(result)); //false
~~~

​	尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控
这些值是可能的，也是必需的。访问 `Number.NEGATIVE_INFINITY` 和 `Number.POSITIVE_INFINITY` 也可以
得到负和正 Infinity 的值。可以想见，这两个属性中分别保存着-Infinity 和Infinity。  

### 4.5.3 `NaN`

​	`NaN`，即非数值（ Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以 0 都会导致错误，从而停止代码执行。但在 `ECMAScript` 中，任何数值除以 0 会返回 `NaN`(实际上只有 0 除以 0 才会返回 `NaN`，正数除以 0 返回 Infinity，负数除以 0 返回-Infinity )，因此不会影响其他代码的执行。
​	`NaN` 本身有两个非同寻常的特点。首先，任何涉及 `NaN` 的操作（例如 `NaN`/10）都会返回 `NaN`，这个特点在多步计算中有可能导致问题。其次， `NaN` 与任何值都不相等，包括 `NaN` 本身。例如，下面的代码会返回 false：

~~~javascript
alert(NaN == NaN); //false
~~~

​	针对 `NaN` 的这两个特点， `ECMAScript` 定义了 `isNaN()`函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。 `isNaN()`在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串"10"或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。请看下面的例子：

~~~javascript
alert(isNaN(NaN)); 		//true
alert(isNaN(10)); 		//false（ 10 是一个数值）
alert(isNaN("10")); 	//false（可以被转换成数值 10）
alert(isNaN("blue")); 	//true（不能转换成数值）
alert(isNaN(true)); 	//false（可以被转换成数值 1）  
~~~

​	尽管有点儿不可思议，但 `isNaN()`确实也适用于对象。在基于对象调用 `isNaN()`函数时，会首先调用对象的 `valueOf()`方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 `toString()`方法，再测试返回值。而这个过程也是 `ECMAScript` 中内置函数和操作符的一般执行流程。

### 4.5.4 数值转换

​	有 3 个函数可以把非数值转换为数值： `Number()、 parseInt()和 parseFloat()`。第一个函数，即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这 3 个函数对于同样的输入会有返回不同的结果。
​	Number()函数的转换规则如下：

- 如果是 Boolean 值， true 和 false 将分别被转换为 1 和 0。

- 如果是数字值，只是简单的传入和返回。

- 如果是 null 值，返回 0。

- 如果是 undefined，返回 `NaN`。

- 如果是字符串，遵循下列规则：

  - 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"
    会变成 1， "123"会变成 123，而"011"会变成 11（注意：前导的零被忽略了）；
  - 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽
    略前导零）；
  - 如果字符串中包含有效的十六进制格式，例如"`0xf`"，则将其转换为相同大小的十进制整
    数值；
  - 如果字符串是空的（不包含任何字符），则将其转换为 0；
  - 如果字符串中包含除上述格式之外的字符，则将其转换为 `NaN`。

- 如果是对象，则调用对象的 `valueOf()`方法，然后依照前面的规则转换返回的值。如果转换的结果是 `NaN`，则调用对象的 `toString()`方法，然后再次依照前面的规则转换返回的字符串值。

  根据这么多的规则使用 Number()把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子吧。

  ~~~javascript
  var num1 = Number("Hello world!"); //NaN
  var num2 = Number(""); //0
  var num3 = Number("000011"); //11
  var num4 = Number(true); //1
  ~~~

  ​	**一元加操作符的操作与 Number()函数相同.**
  ​	由于 Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是`parseInt()`函数。 `parseInt()`函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号， `parseInt()`就会返回 `NaN`；也就是说，用 `parseInt()`转换空字符串会返回 `NaN`（ Number()对空字符返回 0）。如果第一个字符是数字字符， `parseInt()`会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如， "`1234blue`"会被转换为 1234，因为"blue"会被完全忽略。类似地， "22.5"会被转换为 22，因为小数点并不是有效的数字字符。
  ​	如果字符串中的第一个字符是数字字符， `parseInt()`也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制数）。也就是说，如果字符串以"`0x`"开头且后跟数字字符，就会将其当作一个十六进制整数；如果字符串以"0"开头且后跟数字字符，则会将其当作一个八进制数来解析。

  ​	为了更好地理解 `parseInt()`函数的转换规则，下面给出一些例子：

  ~~~javascript
  var num1 = parseInt("1234blue"); // 1234
  var num2 = parseInt(""); // NaN
  var num3 = parseInt("0xA"); // 10（十六进制数）
  var num4 = parseInt(22.5); // 22
  var num5 = parseInt("070"); // 56（八进制数）
  var num6 = parseInt("70"); // 70（十进制数）
  var num7 = parseInt("0xf"); // 15（十六进制数）
  ~~~

  ​	在使用 `parseInt()`解析像八进制字面量的字符串时， `ECMAScript` 3 和 5 存在分歧。例如：

  ~~~javascript
  //ECMAScript 3 认为是 56（八进制）， ECMAScript 5 认为是 70（十进制）
  var num = parseInt("070");
  ~~~

  ​	在 `ECMAScript` 3 JavaScript 引擎中， "070"被当成八进制字面量，因此转换后的值是十进制的 56。而在 `ECMAScript` 5 JavaScript 引擎中， `parseInt()`已经不具有解析八进制值的能力，因此前导的零会被认为无效，从而将这个值当成"70"，结果就得到十进制的 70。在 `ECMAScript` 5 中，即使是在非严格模式下也会如此。
  ​	为了消除在使用 `parseInt()`函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16 作为第二个参数，可以保证得到正确的结果，例如：

  ~~~javascript
  var num = parseInt("0xAF", 16); //175
  ~~~

  ​	实际上，如果指定了 16 作为第二个参数，字符串可以不带前面的"`0x`"，如下所示：

  ~~~javascript
  var num1 = parseInt("AF", 16); //175
  var num2 = parseInt("AF"); //NaN  
  ~~~

  ​	指定基数会影响到转换的输出结果。例如：

  ~~~javascript
  var num1 = parseInt("10", 2); //2 （按二进制解析）
  var num2 = parseInt("10", 8); //8 （按八进制解析）
  var num3 = parseInt("10", 10); //10 （按十进制解析）
  var num4 = parseInt("10", 16); //16 （按十六进制解析）
  ~~~

  ​	不指定基数意味着让 `parseInt()`决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。多数情况下，我们要解析的都是十进制数值，因此始终将 10 作为第二个参数是非常必要的。

  ​	与 `parseInt()`函数类似， `parseFloat()`也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，"22.34.5"将会被转换为 22.34。
  ​	除了第一个小数点有效之外， `parseFloat()`与 `parseInt()`的第二个区别在于它始终都会忽略前导的零。 `parseFloat()`可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 0。由于 `parseFloat()`只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零）， `parseFloat()`会返回整数。以下是使用 `parseFloat()`转换数值的几个典型示例。

  ~~~javascript
  var num1 = parseFloat("1234blue"); //1234 （整数）
  var num2 = parseFloat("0xA"); //0
  var num3 = parseFloat("22.5"); //22.5
  var num4 = parseFloat("22.34.5"); //22.34
  var num5 = parseFloat("0908.5"); //908.5
  var num6 = parseFloat("3.125e7"); //31250000
  ~~~

  ## 4.6 String类型

  ### 4.6.1 字符字面量

  ​	String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。这些字符字面量如下表所示：

  | 字面量   | 含义                                                         |
  | -------- | ------------------------------------------------------------ |
  | `\n`     | 换行                                                         |
  | `\t`     | 制表                                                         |
  | `\b`     | 空格                                                         |
  | `\r`     | 回车                                                         |
  | `\f`     | 进纸                                                         |
  | `\\`     | 斜杠                                                         |
  | `\'`     | 单引号                                                       |
  | `\"`     | 双引号                                                       |
  | `\xnn`   | 以十六进制代码`nn`表示的一个字符（其中n为0 ~ F）。例如`\x41`表示“A” |
  | `\unnnn` | 以十六进制代码`nnnn`表示的一个Unicode字符（其中n为0 ~ F）。例如`\ua303`表示希腊字符Σ |

  ​	字符串的length属性返回的字符数包括 16 位字符的数目。如果字符串中包含双字节字符，那么 length 属性
  可能不会精确地返回字符串中的字符数目。

  ### 4.6.2 字符串的特点

  ​	`ECMAScript` 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，例如：

  ~~~javascript
  var lang = "Java";
  lang = lang + "Script";
  ~~~

  ​	以上示例中的变量 `lang` 开始时包含字符串"Java"。而第二行代码把 `lang` 的值重新定义为"Java"与"Script"的组合，即"JavaScript"。实现这个操作的过程如下：首先创建一个能容纳 10 个字符的新字符串，然后在这个字符串中填充"Java"和"Script"，最后一步是销毁原来的字符串"Java"和字符串"Script"，因为这两个字符串已经没用了。这个过程是在后台发生的，而这也是在某些旧版本的浏览器（例如版本低于 1.0 的 Firefox、 IE 6 等）中拼接字符串时速度很慢的原因所在。但这些浏览器后来的版本已经解决了这个低效率问题。  

  ### 4.6.3 转换为字符串

  ​	要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 `toString()`方法。这个方法唯一要做的就是返回相应值的字符串表现。来看下面的例子：

  ~~~javascript
  var age = 11;
  var ageAsString = age.toString(); // 字符串"11"
  var found = true;
  var foundAsString = found.toString(); // 字符串"true"
  ~~~

  ​	数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 `toString()`方法，该方法返回字符串的一个副本）都有 `toString()`方法。但 null 和 undefined 值没有这个方法。
  ​	多数情况下，调用 `toString()`方法不必传递参数。但是，在调用数值的` toString()`方法时，可以传递一个参数：输出数值的基数。默认情况下，`toString()`方法以十进制格式返回数值的字符串表示。而通过传递基数， `toString()`可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。下面给出几个例子：

  ~~~javascript
  var num = 10;
  alert(num.toString()); // "10"
  alert(num.toString(2)); // "1010"
  alert(num.toString(8)); // "12"
  alert(num.toString(10)); // "10"
  alert(num.toString(16)); // "a  
  ~~~

  ​	在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 String()，这个函数能够将任何类型的值转换为字符串。 String()函数遵循下列转换规则：

- 如果值有 `toString()`方法，则调用该方法（没有参数）并返回相应的结果；

- 如果值是 null，则返回"null"；

- 如果值是 undefined，则返回"undefined"。
  下面再看几个例子：

  ~~~javascript
  var value1 = 10;
  var value2 = true;
  var value3 = null;
  var value4;
  alert(String(value1)); // "10"
  alert(String(value2)); // "true"
  alert(String(value3)); // "null"
  alert(String(value4)); // "undefined"  
  ~~~

  **要把某个值转换为字符串，可以使用加号操作符把它与一个字符串（ ""）加在一起。**

### 4.7 Object类型

​	`ECMAScript`中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示：

~~~javascript
var o = new Object();
~~~

​	这个语法与 Java 中创建对象的语法相似；但在 `ECMAScript` 中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那对圆括号（但这不是推荐的做法）：

~~~javascript
var o = new Object; // 有效，但不推荐省略圆括号
~~~

​	仅仅创建 Object 的实例并没有什么用处，但关键是要理解一个重要的思想：即在 `ECMAScript` 中，（就像 Java 中的 `java.lang.Object` 对象一样） Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。
​	Object 的每个实例都具有下列属性和方法。

- constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（ constructor）就是 Object()。
- `hasOwnProperty(propertyName)`：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（ `propertyName`）必须以字符串形式指定（例如： `o.hasOwnProperty("name")`）。
- `isPrototypeOf(object)`：用于检查传入的对象是否是传入对象的原型。
- `propertyIsEnumerable(propertyName)`：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 `hasOwnProperty()`方法一样，作为参数的属性名必须以字符串形式指定。
- `toLocaleString()`：返回对象的字符串表示，该字符串与执行环境的地区对应。
- `toString()`：返回对象的字符串表示。
- `valueOf()`：返回对象的字符串、数值或布尔值表示。通常与 `toString()`方法的返回值相同。  

从技术角度讲， `ECMA-262` 中对象的行为不一定适用于 JavaScript 中的其他对象。浏览器环境中的对象，比如 `BOM` 和 DOM 中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。 `ECMA-262` 不负责定义宿主对象，因此宿主对象可能会也可能不会继承 Object。

# 5 操作符

## 5.1 一元操作符

#### 5.1.1 递增和递减操作符

​	前置/后置递增/递减操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则。

- 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。
- 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 `NaN`。字符串变量变成数值变量。
- 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。
- 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。
- 在应用于浮点数值时，执行加减 1 的操作。
- 在应用于对象时，先调用对象的 `valueOf()`方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 `NaN`，则在调用 `toString()`方法后再应用前述规则。对象变量变成数值变量。
  以下示例展示了上面的一些规则：  

~~~javascript
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function() {
        return -1;
    }
};
s1++; // 值变成数值 3
s2++; // 值变成 NaN
b++; // 值变成数值 1
f--; // 值变成 0.10000000000000009（由于浮点舍入错误所致）
o--; // 值变成数值-2
~~~

#### 5.1.2 一元加和减操作符

​	一元加操作符以一个加号（ +）表示，放在数值前面，对数值不会产生任何影响。不过，在对非数值应用一元加操作符时，该操作符会像 Number()转型函数一样对这个值执行转换。换句话说，布尔值 false 和 true 将被转换为 0 和 1，字符串值会被按照一组特殊的规则进行解析，而对象是先调用它们的 `valueOf()`和（或） `toString()`方法，再转换得到的值。
​	下面的例子展示了对不同数据类型应用一元加操作符的结果：

~~~javascript


var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function() {
        return -1;
	}
};
s1 = +s1; // 值变成数值 1
s2 = +s2; // 值变成数值 1.1
s3 = +s3; // 值变成 NaN
b = +b; // 值变成数值 0
f = +f; // 值未变，仍然是 1.1
o = +o; // 值变成数值-1  
~~~

​	一元减操作符主要用于表示负数，例如将 1 转换成-1。  在将一元减操作符应用于数值时，该值会变成负数（如上面的例子所示）。而当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数，如下面的例子所示：

~~~javascript
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function() {
    	return -1;
    }
};
s1 = -s1; // 值变成了数值-1
s2 = -s2; // 值变成了数值-1.1
s3 = -s3; // 值变成了 NaN
b = -b; // 值变成了数值 0
f = -f; // 变成了-1.1
o = -o; // 值变成了数值 1 
~~~

## 5.2 位操作符

​	位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。 `ECMAScript` 中的所有数值都以 `IEEE-754` 64 位格式存储，但位操作符并不直接操作 64 位的值。而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再将结果转换回 64 位。对于开发人员来说，由于 64 位存储格式是透明的，因此整个过程就像是只存在 32 位的整数一样。
​	对于有符号的整数， 32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号： 0 表示正数， 1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储， 31 位中的每一位都表示 2 的幂。没 有 用 到 的 位 以 0 填 充 ， 即 忽 略 不 计 。 例 如 ， 数 值 18 的 二 进 制 表 示 是00000000000000000000000000010010，或者更简洁的 10010。
​	负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列 3 个步骤：  

- (1) 求这个数值绝对值的二进制码（例如，要求-18 的二进制补码，先求 18 的二进制码）；
- (2) 求二进制反码，即将 0 替换为 1，将 1 替换为 0；
- (3) 得到的二进制反码加 1。

​	要根据这 3 个步骤求得-18 的二进制码，首先就要求得 18 的二进制码，即：

​	0000 0000 0000 0000 0000 0000 0001 0010

​	然后，求其二进制反码，即 0 和 1 互换：

​	1111 1111 1111 1111 1111 1111 1110 1101

​	最后，二进制反码加 1：

​	1111 1111 1111 1111 1111 1111 1110 1101
​																			1

---------------------------------------
​	1111 1111 1111 1111 1111 1111 1110 1110
​	这样，就求得了18 的二进制表示，即 11111111111111111111111111101110。要注意的是，在处理有
符号整数时，是不能访问位 31 的。
​	`ECMAScript` 会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。如下面的例子所示：

~~~javascript
var num = -18;
alert(num.toString(2)); // "-10010"
~~~

​	要把数值-18 转换成二进制字符串时，得到的结果是"-10010"。这说明转换过程理解了二进制补码并将其以更合乎逻辑的形式展示了出来。  

​	在 `ECMAScript` 中，当对数值应用位操作符时，后台会发生如下转换过程： 64 位的数值被转换成 32位数值，然后执行位操作，最后再将 32 位的结果转换回 64 位数值。这样，表面上看起来就好像是在操作 32 位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重的副效应，即在对特殊的 `NaN `和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。

​	如果对非数值应用位操作符，会先使用 Number()函数将该值转换为一个数值（自动完成），然后再应用位操作。得到的结果将是一个数值。  

- 按位非（~）：结果就是返回数值的反码。按位非操作的本质：操作数的负值减 1。  
- 按位与（&）：
- 按位或（|）：
- 按位异或（^）:
- 左移(<<):这个操作符会将数值的所有位向左移动指定的位数。在向左移位后，原数值的右侧多出了 5 个空位左移操作会以 0 来填充这些空位，以便得到的结果是一个完整的 32 位二进制数。注意，左移不会影响操作数的符号位。换句话说，如果将-2 向左移动 5 位，结果将是-64，而非 64。  
- 有符号右移(>>):这个操作符会将数值向右移动，但保留符号位（即正负号标记）。有符号的右移操作与左移操作恰好相反。同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的右侧。而此时 `ECMAScript` 会用符号位的值来填充所有空位，以便得到一个完整的值。  
- 无符号右移(>>>):这个操作符会将数值的所有 32 位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。  但是对负数来说，情况就不一样了。首先，无符号右移是以 0 来填充空位，而不是像有符号右移那
  样以符号位的值来填充空位。  其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。

## 5.3 布尔操作符

### 5.3.1 逻辑非(!)

​	无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。也就是说，逻辑非操作符遵循下列规则：

- 如果操作数是一个对象，返回 false；
- 如果操作数是一个空字符串，返回 true；
- 如果操作数是一个非空字符串，返回 false；
- 如果操作数是数值 0，返回 true；
- 如果操作数是任意非 0 数值（包括 Infinity），返回 false；
- 如果操作数是 null，返回 true；
- 如果操作数是 `NaN`，返回 true；
- 如果操作数是 undefined，返回 true。
  下面几个例子展示了应用上述规则的结果：

~~~javascript
alert(!false); // true
alert(!"blue"); // false
alert(!0); // true
alert(!NaN); // true
alert(!""); // true
alert(!12345); // false
~~~

​	逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟 Boolean()转型函数的行为。  

### 5.3.2 逻辑与(&&)

​	逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：

- 如果第一个操作数是对象，则返回第二个操作数；
- 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；
- 如果两个操作数都是对象，则返回第二个操作数；
- 如果有一个操作数是 null，则返回 null；
- 如果有一个操作数是 `NaN`，则返回 `NaN`；
- 如果有一个操作数是 undefined，则返回 undefined。

​	逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false，则无论第二个操作数是什么值，结果都不再可能是true 了。  

### 5.3.3 逻辑或(||)

​	与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：

- 如果第一个操作数是对象，则返回第一个操作数；
- 如果第一个操作数的求值结果为 false，则返回第二个操作数；
- 如果两个操作数都是对象，则返回第一个操作数；
- 如果两个操作数都是 null，则返回 null；
- 如果两个操作数都是 `NaN`，则返回 `NaN`；
- 如果两个操作数都是 undefined，则返回 undefined。

​	与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。  

## 5.4 乘性操作符

​	`ECMAScript` 定义了 3 个乘性操作符：乘法、除法和求模。这些操作符与 Java、 C 或者 Perl 中的相应操作符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用 Number()转型函数将其转换为数值。也就是说，空字符串将被当作0，布尔值 true 将被当作 1。  

### 5.4.1 乘法

​	在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：

- 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 `ECMAScript` 数值的表示范围，则返回 Infinity 或-Infinity；
- 如果有一个操作数是 `NaN`，则结果是 `NaN`；
- 如果是 Infinity 与 0 相乘，则结果是 `NaN`；
- 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；
- 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。  

### 5.4.2 除法

​	与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下：

- 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 `ECMAScript` 数值的表示范围，则返回 Infinity 或-Infinity；
- 如果有一个操作数是 `NaN`，则结果是 `NaN`；
- 如果是 Infinity 被 Infinity 除，则结果是 `NaN`；
- 如果是零被零除，则结果是 `NaN`；
- 如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；  
- 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。

### 5.4.3 求模

​	与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值：

- 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
- 如果被除数是无穷大值而除数是有限大的数值，则结果是 `NaN`；
- 如果被除数是有限大的数值而除数是零，则结果是 `NaN`；
- 如果是 Infinity 被 Infinity 除，则结果是 `NaN`；
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
- 如果被除数是零，则结果是零；
- 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。  

## 5.5 加性操作符

​	在 `ECMAScript` 中，这两个操作符却都有一系列的特殊行为。与乘性操作符类似，加性操作符也会在后台转换不同的数据类型。然而，对于加性操作符而言，相应的转换规则还稍微有点复杂。  

### 5.5.1 加法

​	如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：

- 如果有一个操作数是 `NaN`，则结果是 `NaN`；
- 如果是 Infinity 加 Infinity，则结果是 Infinity；
- 如果是-Infinity 加-Infinity，则结果是-Infinity；
- 如果是 Infinity 加-Infinity，则结果是 `NaN`；
- 如果是+0 加+0，则结果是+0；
- 如果是-0 加-0，则结果是-0；
- 如果是+0 加-0，则结果是+0。

​	 不过，如果有一个操作数是字符串，那么就要应用如下规则：

- 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。
- 如果有一个操作数是对象、数值或布尔值，则调用它们的 `toString()`方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符串"undefined"和"null"。  

### 5.5.2 减法

​	与加法操作符类似， ECMAScript 中的减法操作符在处理各种数据类型转换时，同样需要遵循一些特殊规则，如下所示：

- 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；

- 如果有一个操作数是 `NaN`，则结果是 `NaN`；

- 如果是 Infinity 减 Infinity，则结果是 `NaN`；

- 如果是-Infinity 减-Infinity，则结果是 `NaN`；

- 如果是 Infinity 减-Infinity，则结果是 Infinity；

- 如果是-Infinity 减 Infinity，则结果是-Infinity；

- 如果是+0 减+0，则结果是+0；

- 如果是+0 减-0，则结果是-0；  

- 如果是0 减0，则结果是+0；

- 如果有一个操作数是字符串、布尔值、 null 或 undefined，则先在后台调用 Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 `NaN`，则减法的结果就是 `NaN`；

- 如果有一个操作数是对象，则调用对象的 `valueOf()`方法以取得表示该对象的数值。如果得到的值是 `NaN`，则减法的结果就是 `NaN`。如果对象没有 `valueOf()`方法，则调用其 `toString()`方法并将得到的字符串转换为数值。  

  下面几个例子展示了上面的规则：  

  ~~~javascript
  var result1 = 5 - true; // 4，因为 true 被转换成了 1
  var result2 = NaN - 1; // NaN
  var result3 = 5 - 3; // 2
  var result4 = 5 - ""; // 5，因为"" 被转换成了 0
  var result5 = 5 - "2"; // 3，因为"2"被转换成了 2
  var result6 = 5 - null; // 5，因为 null 被转换成了 0
  ~~~

## 5.6 关系操作符

​	与 `ECMAScript` 中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。

- 如果两个操作数都是数值，则执行数值比较。
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- 如果一个操作数是对象，则调用这个对象的 `valueOf()`方法，用得到的结果按照前面的规则执行比较。如果对象没有 `valueOf()`方法，则调用 `toString()`方法，并用得到的结果根据前面的规则执行比较。
- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。  

## 5.7 相等操作符

​	确定两个变量是否相等是编程中的一个非常重要的操作。在比较字符串、数值和布尔值的相等性时，问题还比较简单。但在涉及到对象的比较时，问题就变得复杂了。最早的 `ECMAScript` 中的相等和不等操作符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质疑。最后， `ECMAScript` 的解决方案就是提供两组操作符： 相等和不相等——先转换再比较， 全等和不全等——仅比较而不转换。  

### 5.7.1 相等(==)和不相等(!=)

​	这两个操作符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

- 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而true 转换为 1；
- 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
- 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较；

​	这两个操作符在进行比较时则要遵循下列规则。

- null 和 undefined 是相等的。
- 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。
- 如果有一个操作数是 `NaN`，则相等操作符返回 false，而不相等操作符返回 true。重要提示：即使两个操作数都是 `NaN`，相等操作符也返回 false；因为按照规则， `NaN` 不等于 `NaN`。
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false。  

​	下表列出了一些特殊情况及比较结果：  

| 表达式            | 值    |
| ----------------- | ----- |
| null == undefined | true  |
| "`NaN`" == `NaN`  | false |
| 5 == `NaN`        | false |
| `NaN` == `NaN`    | false |
| `NaN` != `NaN`    | true  |
| false == 0        | true  |
| true == 1         | true  |
| true == 2         | false |
| undefined == 0    | false |
| null == 0         | false |
| "5" == 5          | true  |

### 5.7.2 全等(===)和不全等(!==)

​	除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。它只在两个操作数未经转换就相等的情况下返回 true，如下面的例子所示：  

~~~javascript
var result1 = ("55" == 55); //true，因为转换后相等
var result2 = ("55" === 55); //false，因为不同的数据类型不相等
~~~

​	不全等操作符在两个操作数未经转换就不相等的情况下返回 true。例如：  

~~~javascript
var result1 = ("55" != 55); //false，因为转换后相等
var result2 = ("55" !== 55); //true，因为不同的数据类型不相等
~~~

​	**记住： null == undefined 会返回 true，因为它们是类似的值；但 null === undefined 会返回 false，因为它们是不同类型的值。**
​	**由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。**

## 5.8 条件操作符、赋值操作符、逗号操作符都与Java中的语法形式一致

# 6 语句

## 6.1 if、do..while、while、for、label、break、continue语句都与Java中的语法形式一致

## 6.2 for-in语句

​	for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的示例：

~~~javascript
for (var propName in window) {
	document.write(propName);
}
~~~

​	在这个例子中，我们使用 for-in 循环来显示了 `BOM` 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 propName。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。
​	`ECMAScript` 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。
​	但是，如果表示要迭代的对象的变量值为 null 或 undefined， for-in 语句会抛出错误。`ECMAScript` 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。  

## 6.3 with语句

​	with 语句的作用是将代码的作用域设置到一个特定的对象中。 with 语句的语法如下：

~~~javascript
with (expression) statement;
~~~

​	定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示：

~~~javascript
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;
~~~

​	上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示：

~~~javascript
with(location){
    var qs = search.substring(1);
    var hostName = hostname;
    var url = href;
}
~~~

​	在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location 对象中是否有同名的属性。如果发现了同名属性， 则以 location 对象属性的值作为变量的值。

​	**严格模式下不允许使用 with 语句，否则将视为语法错误。由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。**

## 6.4 switch语句

​	`ECMAScript` 中 switch 语句的语法与其他基于 C 的语言非常接近。但这个语句也有自己的特色。首先，可以在
switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。请看下面这个例子：

~~~javascript
switch ("hello world") {
	case "hello" + " world":
		alert("Greeting was found.");
		break;
	case "goodbye":
		alert("Closing was found.");
		break;
	default:
		alert("Unexpected message was found.");
}
~~~

​	在这个例子中， switch 语句使用的就是字符串。其中，第一种情形实际上是一个对字符串拼接操作求值的表达式。由于这个字符串拼接表达式的结果与 switch 的参数相等，因此结果就会显示"Greeting was found."。而且，使用表达式作为 case 值还可以实现下列操作：

~~~javascript
var num = 25;
switch (true) {
    case num < 0:
        alert("Less than 0.");
        break;
    case num >= 0 && num <= 10:
        alert("Between 0 and 10.");
        break;
    case num > 10 && num <= 20:
        alert("Between 10 and 20.");
        break;
    default:
    	alert("More than 20.");
}
~~~

​	这个例子首先在 switch 语句外面声明了变量 `num`。而之所以给 switch 语句传递表达式 true，是因为每个 case 值都可以返回一个布尔值。这样，每个 case 按照顺序被求值，直到找到匹配的值或者遇到 default 语句为止（这正是这个例子的最终结果）。
​	**switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串"10"不等于数值 10）。**

# 7 函数

​	推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。否则，如果函数有时候返回值，有时候有不返回值，会给调试代码带来不便。
严格模式对函数有一些限制：

- 不能把函数命名为 `eval` 或 arguments；
- 不能把参数命名为 `eval` 或 arguments；
- 不能出现两个命名参数同名的情况。
  如果发生以上情况，就会导致语法错误，代码无法执行。  

## 7.1 理解参数

​	`ECMAScript` 函数的参数与大多数其他语言中函数的参数有所不同。`ECMAScript` 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，原因是 `ECMAScript` 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。
​	其实， arguments 对象只是与数组类似（它并不是 Array 的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是 arguments[0]，第二个元素是 arguments[1]，以此类推），使用 length 属性来确定传递进来多少个参数。

​	`ECMAScript` 函数的一个重要特点：命名的参数只提供便利，但不是必需的。另外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但在 `ECMAScript` 中，没有这些条条框框，解析器不会验证命名参数。  	

​	另一个与参数相关的重要方面，就是 arguments 对象可以与命名参数一起使用，如下面的例子所示：

~~~javascript
function doAdd(num1, num2) {
    if(arguments.length == 1) {
    	alert(num1 + 10);
    } else if (arguments.length == 2) {
    	alert(arguments[0] + num2);
    }
}
~~~

​	在重写后的这个 `doAdd()`函数中，两个命名参数都与 arguments 对象一起使用。由于 `num1` 的值与 arguments[0]的值相同，因此它们可以互换使用（当然， `num2` 和 arguments[1]也是如此）。

​	关于 arguments 的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。例如：  

~~~javascript
function doAdd(num1, num2) {
    arguments[1] = 10;
    alert(arguments[0] + num2);
}
~~~


​	每次执行这个 `doAdd()`函数都会重写第二个参数，将第二个参数的值修改为 10。因为 arguments对象中的值会自动反映到对应的命名参数，所以修改 arguments[1]，也就修改了 `num2`，结果它们的值都会变成 10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。另外还要记住，如果只传入了一个参数，那么为 arguments[1]设置的值不会反应到命名参数中。这是因为 arguments 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。  

​	关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予 undefined 值。这就跟定义了变量但又没有初始化一样。例如，如果只给 `doAdd()`函数传递了一个参数，则 `num2` 中就会保存undefined 值。
​	严格模式对如何使用 arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。也就是说，即使把 arguments[1]设置为 10， `num2` 的值仍然还是 undefined。其次，重写arguments 的值会导致语法错误（代码将不会执行）。
​	**`ECMAScript` 中的所有参数传递的都是值，不可能通过引用传递参数。**  

## 7.2 没有重载

​	`ECMAScript` 函数不能像传统意义上那样实现重载。而在其他语言（如 Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述， `ECMAScirpt`函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。如果在 `ECMAScript` 中定义了两个名字相同的函数，则该名字只属于后定义的函数。  