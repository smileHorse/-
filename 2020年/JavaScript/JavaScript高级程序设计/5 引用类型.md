	引用类型的值（对象）是引用类型的一个实例。在 `ECMAScript` 中， 引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管 `ECMAScript`从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。

​	虽然引用类型与类看起来相似，但它们并不是相同的概念。为避免混淆，本书将不使用类这个概念。

​	如前所述，对象是某个特定引用类型的实例。新对象是使用 new 操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。请看下面这行代码：

~~~javascript
var person = new Object();
~~~

​	这行代码创建了 Object 引用类型的一个新实例，然后把该实例保存在了变量 person 中。使用的构造函数是 Object，它只为新对象定义了默认的属性和方法。 `ECMAScript` 提供了很多原生引用类型（例如 Object），以便开发人员用以实现常见的计算任务。  

# 1 Object类型

​	创建 Object 实例的方式有两种。第一种是使用 new 操作符后跟 Object 构造函数；另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。

​	在通过对象字面量定义对象时，实际上不会调用 Object 构造函数（ Firefox 2 及更早版本会调用 Object 构造函数；但 Firefox 3 之后就不会了）。  

​	一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过，在 JavaScript 也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中。从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过变量来访问属性。如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。如下面的例子所示：

~~~javascript
alert(person["name"]); //"Nicholas"
alert(person.name); //"Nicholas"

var propertyName = "name";
alert(person[propertyName]); //"Nicholas"

person["first name"] = "Nicholas";
~~~

# 2 Array类型

​	`ECMAScript` 中的数组与其他多数语言中的数组有着相当大的区别。`ECMAScript` 数组的每一项可以保存任何类型的数据。而且， `ECMAScript` 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。
​	创建数组的基本方式有两种。第一种是使用 Array 构造函数，如下面的代码所示：

~~~javascript
var colors = new Array();
~~~

​	如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成 length属性的值。例如，下面的代码将创建 length 值为 20 的数组：

~~~javascript
var colors = new Array(20);
~~~

​	也可以向 Array 构造函数传递数组中应该包含的项。以下代码创建了一个包含 3 个字符串值的数组：

~~~javascript
var colors = new Array("red", "blue", "green");
~~~

​	当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果传递的是数值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值的只有一项的数组。下面就两个例子：

~~~javascript
var colors = new Array(3); // 创建一个包含 3 项的数组
var names = new Array("Greg"); // 创建一个包含 1 项，即字符串"Greg"的数组
~~~

​	另外，在使用 Array 构造函数时也可以省略 new 操作符。如下面的例子所示，省略 new 操作符的结果相同：

~~~javascript
var colors = Array(3); // 创建一个包含 3 项的数组
var names = Array("Greg"); // 创建一个包含 1 项，即字符串"Greg"的数组
~~~

​	创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开，如下所示：

~~~javascript
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
var names = []; // 创建一个空数组
var values = [1,2,]; // 不要这样！这样会创建一个包含 2 或 3 项的数组
var options = [,,,,,]; // 不要这样！这样会创建一个包含 5 或 6 项的数组
~~~

​	以上代码的第一行创建了一个包含3个字符串的数组。第二行使用一对空方括号创建了一个空数组。第三行展示了在数组字面量的最后一项添加逗号的结果：在 IE 中， values 会成为一个包含 3 个项且每项的值分别为 1、 2 和 undefined 的数组；在其他浏览器中， values 会成为一个包含 2 项且值分别为1 和 2 的数组。原因是 IE 8 及之前版本中的 `ECMAScript` 实现在数组字面量方面存在 bug。由于这个 bug导致的另一种情况如最后一行代码所示，该行代码可能会创建包含 5 项的数组（在 IE 9+、 Firefox、 Opera、Safari 和 Chrome 中），也可能会创建包含 6 项的数组（在 IE 8 及更早版本中）。在像这种省略值的情况下，每一项都将获得 undefined 值；这个结果与调用 Array 构造函数时传递项数在逻辑上是相同的。但是由于 IE 的实现与其他浏览器不一致，因此我们强烈建议不要使用这种语法。

​	与对象一样，在使用数组字面量表示法时，也不会调用 Array 构造函数（ Firefox 3及更早版本除外）。  

​	数组的 length 属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。  

## 2.1 检测数组

​	对于一个网页，或者一个全局作用域而言，使用 `instanceof` 操作符就能得到满意的结果：

~~~javascript
if (value instanceof Array){
	//对数组执行某些操作
}
~~~

​	`instanceof` 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

​	为了解决这个问题， `ECMAScript 5` 新增了 `Array.isArray()`方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。这个方法的用法如下：

~~~javascript
if (Array.isArray(value)){
	//对数组执行某些操作
}  
~~~

## 2.2 转换方法

​	调用数组的 `toString()`方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用 `valueOf()`返回的还是数组。实际上，为了创建这个字符串会调用数组每一项的 `toString()`方法。  `toLocaleString()`方法经常也会返回与 `toString()`和 `valueOf()`方法相同的值，但也不总是如此。当调用数组的 `toLocaleString()`方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的 `toLocaleString()`方法，而不是 `toString()`方法。  

​	使用 join()方法，则可以使用不同的分隔符来构建这个字符串。 join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。  

​	如果数组中的某一项的值是 null 或者 undefined，那么该值在 join()、`toLocaleString()`、 `toString()`和 `valueOf()`方法返回的结果中以空字符串表示。  

## 2.3 栈方法

​	`ECMAScript` 为数组专门提供了 push()和 pop()方法，以便实现类似栈的行为。push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。  

## 2.4 队列方法

​	shift()能够移除数组中的第一个项并返回该项，同时将数组长度减 1。结合使用 shift()和 push()方法，可以像使用队列一样使用数组。

​	`ECMAScript` 还为数组提供了一个 `unshift()`方法。顾名思义， `unshift()`与 shift()的用途相反：它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用 `unshift()`和 pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。

## 2.5 重排序方法

​	reverse()方法会反转数组项的顺序。  

​	在默认情况下， sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序， sort()方法会调用每个数组项的 `toString()`转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串，如下所示：

~~~javascript
var values = [0, 1, 5, 10, 15];
values.sort();
alert(values); //0,1,10,15,5 
~~~

​	这种排序方式在很多情况下都不是最佳方案。因此 sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：  

~~~javascript
function compare(value1, value2) {
    if (value1 < value2) {
    	return -1;
    } else if (value1 > value2) {
    	return 1;
    } else {
    	return 0;
    }
}

var values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values); //0,1,5,10,15
~~~

​	**reverse()和 sort()方法的返回值是经过排序之后的数组。**

 ## 2.6 操作方法

​	`concat()`方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数
添加到这个副本的末尾，最后返回新构建的数组。在没有给 `concat()`方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给 `concat()`方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。下面来看一个例子：

~~~javascript
var colors = ["red", "green", "blue"];
var colors2 = colors.concat("yellow", ["black", "brown"]);
alert(colors); //red,green,blue
alert(colors2); //red,green,blue,yellow,black,brown
~~~

​	`slice()`能够基于当前数组中的一或多个项创建一个新数组。 slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。注意， slice()方法不会影响原始数组。请看下面的例子：

~~~javascript
var colors = ["red", "green", "blue", "yellow", "purple"];
var colors2 = colors.slice(1);
var colors3 = colors.slice(1,4);
alert(colors2); //green,blue,yellow,purple
alert(colors3); //green,blue,yellow  
~~~

​	如果 slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含 5 项的数组上调用 slice(-2,-1)与调用 slice(3,4)得到的结果相同。如果结束位置小于起始位置，则返回空数组。

​	splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下 3 种：

- 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。
- 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,"red","green")会从当前数组的位置 2 开始插入字符串"red"和"green"。
- 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,"red","green")会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串"red"和"green"。

​	splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述 3 种使用 splice()方法的方式：

~~~javascript
var colors = ["red", "green", "blue"];
var removed = colors.splice(0,1); // 删除第一项
alert(colors); // green,blue
alert(removed); // red，返回的数组中只包含一项
removed = colors.splice(1, 0, "yellow", "orange"); // 从位置 1 开始插入两项
alert(colors); // green,yellow,orange,blue
alert(removed); // 返回的是一个空数组
removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项
alert(colors); // green,red,purple,orange,blue
alert(removed); // yellow，返回的数组中只包含一项
~~~

## 2.7 位置方法

​	`ECMAScript 5` 为数组实例添加了两个位置方法： `indexOf()`和 `lastIndexOf()`。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， `indexOf()`方法从数组的开头（位置 0）开始向后查找， `lastIndexOf()`方法则从数组的末尾开始向前查找。
​	这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用===一样）。以下是几个例子：

~~~javascript
var numbers = [1,2,3,4,5,4,3,2,1];
alert(numbers.indexOf(4)); //3 
alert(numbers.lastIndexOf(4)); //5
alert(numbers.indexOf(4, 4)); //5
alert(numbers.lastIndexOf(4, 4)); //3
var person = { name: "Nicholas" };
var people = [{ name: "Nicholas" }];
var morePeople = [person];
alert(people.indexOf(person)); //-1
alert(morePeople.indexOf(person)); //0
~~~

## 2.8 迭代方法

​	`ECMAScript 5` 为数组定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这 5 个迭代方法的作用。

- every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。
- filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。
- `forEach()`：对数组中的每一项运行给定函数。这个方法没有返回值。
- map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
- some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。

​	以上方法都不会修改数组中的包含的值。  

 ## 2.9 归并方法

​	`ECMAScript 5` 还新增了两个归并数组的方法： reduce()和 `reduceRight()`。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中， reduce()方法从数组的第一项开始，逐个遍历到最后。而 `reduceRight()`则从数组的最后一项开始，向前遍历到第一项。

​	这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce()和 `reduceRight()`的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。

​	使用 reduce()方法可以执行求数组中所有值之和的操作，比如：

~~~javascript
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array){
	return prev + cur;
});
alert(sum); //15
~~~

​	第一次执行回调函数， `prev` 是 1， cur 是 2。第二次， `prev` 是 3（ 1 加 2 的结果）， cur 是 3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。
​	`reduceRight()`的作用类似，只不过方向相反而已。来看下面这个例子：

~~~javascript
var values = [1,2,3,4,5];
var sum = values.reduceRight(function(prev, cur, index, array){
	return prev + cur;
});
alert(sum); //15
~~~


​	在这个例子中，第一次执行回调函数， `prev` 是 5， cur 是 4。当然，最终结果相同，因为执行的都是简单相加的操作。使用 reduce()还是 `reduceRight()`，主要取决于要从哪头开始遍历数组。除此之外，它们完全相同。  

# 3 Date类型

​	Date类型使用自 `UTC`（ Coordinated Universal Time，国际协调时间） 1970 年 1 月 1 日午夜（零时）开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下， Date 类型保存的日期能够精确到 1970 年 1月 1 日之前或之后的 285 616 年。
要创建一个日期对象，使用 new 操作符和 Date 构造函数即可，如下所示：

~~~javascript
var now = new Date();
~~~

​	在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从 `UTC` 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数）。为了简化这一计算过程， `ECMAScript` 提供了两个方法： `Date.parse()`和 `Date.UTC()`。

​	其中， `Date.parse()`方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。 `ECMA-262` 没有定义 `Date.parse()`应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。如果传入 `Date.parse()`方法的字符串不能表示日期，那么它会返回 `NaN`。实际上，如果直接将表示日期的字符串传递给 Date 构造函数，也会在后台调用 `Date.parse()`。 

​	`Date.UTC()`方法同样也返回表示日期的毫秒数，但它与 `Date.parse()`在构建值时使用不同的信息。 `Date.UTC()`的参数分别是年份、基于 0 的月份（一月是 0，二月是 1，以此类推）、月中的哪一天（ 1 到 31）、小时数（ 0 到 23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。以下是两个使用 `Date.UTC()`方法的例子：

~~~javascript
// GMT 时间 2000 年 1 月 1 日午夜零时
var y2k = new Date(Date.UTC(2000, 0));
// GMT 时间 2005 年 5 月 5 日下午 5:55:55
var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
~~~

​	如同模仿 `Date.parse()`一样， Date 构造函数也会模仿 `Date.UTC()`，但有一点明显不同：日期和时间都基于本地时区而非 GMT 来创建。不过， Date 构造函数接收的参数仍然与 `Date.UTC()`相同。因此，如果第一个参数是数值， Date 构造函数就会假设该值是日期中的年份，而第二个参数是月份，以此类推。  

~~~javascript
// 本地时间 2000 年 1 月 1 日午夜零时
var y2k = new Date(2000, 0);
// 本地时间 2005 年 5 月 5 日下午 5:55:55
var allFives = new Date(2005, 4, 5, 17, 55, 55);
~~~

​	以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时区创建的。

​	`ECMAScript 5` 添加了 `Data.now()`方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用 Data 对象分析代码的工作。例如：

~~~javascript
//取得开始时间
var start = Date.now();
//调用函数
doSomething();
//取得停止时间
var stop = Date.now(),
result = stop – start;
~~~

​	支持 `Data.now()`方法的浏览器包括 IE 9+、 Firefox 3+、 Safari 3+、 Opera 10.5 和 Chrome。在不支持它的浏览器中，使用+操作符把 Data 对象转换成字符串，也可以达到同样的目的。

~~~javascript
//取得开始时间
var start = +new Date();
//调用函数
doSomething();
//取得停止时间
var stop = +new Date(),
result = stop - start;  
~~~

## 3.1 继承的方法

​	与其他引用类型一样， Date 类型也重写了 `toLocaleString()`、 `toString()`和 `valueOf()`方法；但这些方法返回的值与其他类型中的方法不同。 Date 类型的 `toLocaleString()`方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含 AM 或 PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而 `toString()`方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是 0 到 23）表示。  

​	Date 类型的 `valueOf()`方法，则根本不返回字符串，而是返回日期的毫秒表示。  

## 3.2 日期格式化方法

​	Date 类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下：

- `toDateString()`——以特定于实现的格式显示星期几、月、日和年；
- `toTimeString()`——以特定于实现的格式显示时、分、秒和时区；
- `toLocaleDateString()`——以特定于地区的格式显示星期几、月、日和年；
- `toLocaleTimeString()`——以特定于实现的格式显示时、分、秒；
- `toUTCString()`——以特定于实现的格式完整的 `UTC` 日期。

​	与 `toLocaleString()`和 `toString()`方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。

​	除了前面介绍的方法之外，还有一个名叫 `toGMTString()`的方法，这是一个与`toUTCString()`等价的方法，其存在目的在于确保向后兼容。不过， `ECMAScript` 推荐现在编写的代码一律使用 `toUTCString()`方法。  

## 3.3 日期/时间组件方法

|                        方法                        |                             说明                             |
| :------------------------------------------------: | :----------------------------------------------------------: |
|                    `getTime()`                     |     返回表示日期的毫秒数；与`valueOf()`方法返回的值相同      |
|                  `setTime(毫秒)`                   |               以毫秒数设置日期，会改变整个日期               |
|         `getFullYear() / getUTCFullYear()`         | 取得4位数的年份（如2007而非仅07）/ 返回`UTC`日期的4位数年份  |
|       `setFullYear(年) / setUTCFullYear(年)`       | 设置日期 / `UTC`日期的年份。传入的年份值必须是4位数字（如2007而非仅07） |
|            `getMonth() / getUTCMonth()`            |  返回日期 / `UTC`日期中的月份，其中0表示一月， 11表示十二月  |
|          `setMonth(月) / setUTCMonth(月)`          | 设置日期 / `UTC`日期的月份。传入的月份值必须大于0，超过11则增加年份 |
|             `getDate() / getUTCDate()`             |          返回日期 / `UTC`日期月份中的天数（ 1到31）          |
|           `setDate(日) / setUTCDate(日)`           | 设置日期 / `UTC`日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 |
|              `getDay() / getUTCDay()`              | 返回日期 / `UTC`日期中星期的星期几（其中0表示星期日， 6表示星期六） |
|            `getHours() / getUTCHours()`            |           返回日期 / `UTC`日期中的小时数（ 0到23）           |
|          `setHours(时) / setUTCHours(时)`          | 设置日期 / `UTC`日期中的小时数。传入的值超过了23则增加月份中的天数 |
|          `getMinutes() / getUTCMinutes()`          |           返回日期 / `UTC`日期中的分钟数（ 0到59）           |
|        `setMinutes(分) / setUTCMinutes(分)`        |  设置日期 / `UTC`日期中的分钟数。传入的值超过59则增加小时数  |
|          `getSeconds() / getUTCSeconds()`          |            返回日期 / `UTC`日期中的秒数（ 0到59）            |
|        `setSeconds(秒) / setUTCSeconds(秒)`        |  设置日期 / `UTC`日期中的秒数。传入的值超过了59会增加分钟数  |
|     `getMilliseconds() / getUTCMilliseconds()`     |                返回日期 / `UTC`日期中的毫秒数                |
| `setMilliseconds(毫秒) / setUTCMilliseconds(毫秒)` |                设置日期 / `UTC`日期中的毫秒数                |
|               `getTimezoneOffset()`                | 返回本地时间与`UTC`时间相差的分钟数。例如，美国东部标准时间返回300。在某地进入夏令时的情况下，这个值会有所变化 |

# 4 `RegExp`类型

​	`ECMAScript` 通过 `RegExp` 类型来支持正则表达式。使用下面类似 Perl 的语法，就可以创建一个正则表达式。

~~~javascript
var expression = / pattern / flags ;
~~~

​	其中的模式（ pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（ flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列 3 个标志：

- g：表示全局（ global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
- i：表示不区分大小写（ case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
- m：表示多行（ `multiline`）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

​	因此，一个正则表达式就是一个模式与上述 3 个标志的组合体。不同组合产生不同结果，如下面的例子所示：

~~~javascript
// 匹配字符串中所有"at"的实例
var pattern1 = /at/g;

// 匹配第一个"bat"或"cat"，不区分大小写
var pattern2 = /[bc]at/i;

// 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写
var pattern3 = /.at/gi;
~~~

​	与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：( [ { \ ^ $ | ) ? * + .]}

​	这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。下面给出几个例子：

~~~javascript
// 匹配第一个"bat"或"cat"，不区分大小写  
var pattern1 = /[bc]at/i;

// 匹配第一个" [bc]at"，不区分大小写
var pattern2 = /\[bc\]at/i;

// 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写
var pattern3 = /.at/gi;

// 匹配所有".at"，不区分大小写
var pattern4 = /\.at/gi;
~~~

​	前面举的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用`RegExp` 构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示：

~~~javascript
// 匹配第一个"bat"或"cat"，不区分大小写
var pattern1 = /[bc]at/i;

// 与 pattern1 相同，只不过是使用构造函数创建的
var pattern2 = new RegExp("[bc]at", "i");
~~~

​	在此， `pattern1` 和 `pattern2` 是两个完全等价的正则表达式。要注意的是，传递给 `RegExp` 构造函数的两个参数都是字符串（不能把正则表达式字面量传递给 `RegExp` 构造函数）。由于 `RegExp` 构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如`\n`（字符`\`在字符串中通常被转义为`\\`，而在正则表达式字符串中就会变成`\\\\`）。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用 `RegExp` 构造函数定义相同模式时使用的字符串。  

|     字面量模式     |      等价的字符串       |
| :----------------: | :---------------------: |
|    `/\[bc\]at/`    |     `/\\[bc\\]at/`      |
|      `/\.at/`      |        `/\\.at/`        |
|   `/name\/age/`    |     `/name\\/age/`      |
|   `/\d.\d{1,2}/`   |    `/\\d.\\d{1,2}/`     |
| `/\w\\hello\\123/` | `/\\w\\\\hello\\\\123/` |

​	使用正则表达式字面量和使用 `RegExp` 构造函数创建的正则表达式不一样。在 `ECMAScript 3` 中，正则表达式字面量始终会共享同一个 `RegExp` 实例，而使用构造函数创建的每一个新 `RegExp` 实例都是一个新实例。来看下面的例子：

~~~javascript
var re = null, i;
for (i=0; i < 10; i++){
    re = /cat/g;
    re.test("catastrophe");
}
for (i=0; i < 10; i++){
    re = new RegExp("cat", "g");
    re.test("catastrophe");
}
~~~


​	在第一个循环中，即使是循环体中指定的，但实际上只为`/cat/`创建了一个 `RegExp` 实例。由于实例属性不会重置，所以在循环中再次调用 test()方法会失败。这是因为第一次调用 test()找到了"cat"，但第二次调用是从索引为 3 的字符（上一次匹配的末尾）开始的，所以就找不到它了。由于会测试到字符串末尾，所以下一次再调用 test()就又从开头开始了。
​	第二个循环使用 `RegExp` 构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的`RegExp` 实例，所以每次调用 test()都会返回 true。
​	`ECMAScript 5` 明确规定，使用正则表达式字面量必须像直接调用 `RegExp` 构造函数一样，每次都创建新的 `RegExp` 实例。 IE 9+、 Firefox 4+和 Chrome 都据此做出了修改。

# 5 Function类型

# 6 基本包装类型

# 7 单体内置对象

