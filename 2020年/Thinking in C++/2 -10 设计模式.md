# 2 -10 设计模式

## 1 模式的概念

​	最初，可以将模式看做解决某一类特定问题的特别巧妙和具有洞察力的方法。它体现出一支开发团队从一个问题的所有角度出发做出全面的分析后，提出的最通用最灵活的对这类问题的解决方案。

​	可以把模式的基本概念看做一般情况下程序设计的基本概念：增加一些抽象层。当人们对事物进行抽象的时候，隔离特定的细节，最直接的动机之一就是为了**使变化的事物和不变的事物分离开**。做到这一点的另一个方法是，一旦发现程序中的某些部分可能被修改，那么就要阻止那些修改在代码中导出传播副作用。如果做到了这一点，代码不仅比较容易阅读和理解，而且也比较容易维护，这样做就会带来一个注定的结果，就是在软件开发的全过程中降低成本。

​	开发一种优雅和可维护的软件设计最困难的部分，常常是发现所谓的**“变化向量”**。这就意味着寻找系统中变化的最重要的事物，换句话说，寻找系统中开发成本最高的地方。一旦找到这个**“变化向量”**，就可以围绕这个焦点来构建系统的设计。

​	因此，设计模式的目标是**封装变化**。

​	**对象组合优于类继承。一个似乎需要继承的设计常常能够戏剧性的使用组合来代替而大大简化，从而使其更灵活。因此，在考虑一个设计时，问问自己：“使用组合是不是更简单？这里真的需要继承吗？它能带来什么好处？”**

## 2 模式的分类

​	`GoF`讨论了23中模式，按照下面三种目的分类：

- **1 创建型(`Creational`)：**用于怎样创建一个对象。通常包括隔离对象创建的细节，这样代码不依赖于对象是什么类型，因此在增加一种新的对象类型时不需要改变代码。例如单例(`Singleton`)模式、工厂(`Factory`)模式和构建器(`Builder`)模式。
- **2 结构型(`Structural`)：**影响对象之间的连接方式，确保系统的变化不需要改变对象间的连接。结构型模式常常由工程项目限制条件来支配。例如代理(`Proxy`)模式和适配器(`Aaapter`)模式。
- **3 行为型(`Behavioral`)：**在程序中处理具有特定操作类型的对象。这些对象封装要执行的操作过程，比如解释一种语言、实践一个请求、遍历一个序列或者实现一种算法。例如命令(`Command`)模式、模板方法(`Template Method`)模式、状态(`State`)模式、策略(`Strategy`)模式、职责链(`Chain of Responsibility`)模式、观察者(`Observer`)模式、多派遣(`Multiple Dispatching`)模式和访问者(`Visitor`)模式。

## 3 单例

​	单例是允许一个类有且仅有一个实例的方法。

~~~c++
#include <iostream>
using namespace std;

class Singleton {
	static Singleton s;
	int i;
	Singleton(int x) : i(x) {}
	Singleton& operator=(const Singleton&);
	Singleton(const Singleton&);
public:
	static Singleton& instance() { return s; }
	int getValue() { return i; }
	void setValue(int x) { i = x; }
};

Singleton Singleton::s(47);

int main() {
	Singleton& s = Singleton::instance();
	cout << s.getValue() << endl;
	Singleton& s2 = Singleton::instance();
	s2.setValue(9);
	cout << s.getValue() << endl;
}
~~~

​	创建一个单例模式的关键是防止客户程序员获得任何控制其对象生存期的权利。为了做到这一点，声明所有的构造函数为私有，并且防止编译器隐式生成任何构造函数。拷贝构造函数和赋值操作符（故意没有实现，因为它们根本不会被调用）被声明为私有，以便防止任何这类复制动作的产生。

​	还必须决定如何去创建这个对象。在这里，它是被静态创建的。也可以等待，直到客户程序员提出要求再根据要求进行创建。这被称作惰性初始化，这种做法，只在创建对象的代价不大，并且并不总是需要它的情况下才有意义。

​	返回引用，而不是返回指针，是一种安全的实现方法。

​	**单例的变体**	

- 将在一个成员函数内部的静态对象的创建与单例类结合在一起：

~~~c++
class Singleton {
	int i;
	Singleton(int x) : i(x) {}
	Singleton& operator=(const Singleton&);
	Singleton(const Singleton&);
public:
	static Singleton& instance() { 
		static Singleton s(47);
		return s; 
	}
	int getValue() { return i; }
	void setValue(int x) { i = x; }
};
~~~

- 如果两个单件彼此依赖，就会产生一个特别有趣的情况：

~~~c++
class Singleton1 {
	Singleton1() {}
public:
	static Singleton1& ref() {
		static Singleton1 single;
		return single;
	}
};

class Singleton2 {
	Singleton1& s1;
	Singleton2(Singleton1& s) : s1(s) {}
public:
	static Singleton2& ref() {
		static Singleton2 single(Singleton1::ref());
		return single;
	}
	Singleton1& f() { return s1; }
};

int main() {
	Singleton1& s1 = Singleton2::ref().f();
}
~~~

​	当调用`Singleton2::ref()`时，它导致其唯一的`Singleton2`对象被创建。在这个对象的创建过程中，`Singleton1::ref()`被调用，这导致其唯一的`Singleton1`对象被创建。因为这种技术不依赖连接或装载的顺序，因此程序员能够很好的控制初始化的全过程，而导致较少的错误。

- 采用将一个对象的**单件属性**从其实现中分离出来的方法：

~~~c++
#include <iostream>
using namespace std;

template<class T> class Singleton {
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
protected:
	Singleton() {}
	virtual ~Singleton() {}
public:
	static T& instance() {
		static T theInstance;
		return theInstance;
	}
};

// A sample class to be made into a singleton
class MyClass : public Singleton<MyClass> {
	int x;
protected:
	friend class Singleton<MyClass>;
	MyClass() { x = 0; }
public:
	void setValue(int n) { x = n; }
	int getValue() const { return x; }
};

int main() {
	MyClass& m = MyClass::instance();
	cout << m.getValue() << endl;
	m.setValue(1);
	cout << m.getValue() << endl;
}
~~~

​	`MyClass`通过下面三个步骤产生一个单例：

1. 声明其构造函数为私有或保护的。
2. 声明类`Singleton<MyClass>`为友元。
3. 从`Singleton<MyClass>`派生出`MyClass`。

​	第三步中的自引用可能令人难以置信。这只是对模板`Singleton`中模板参数的静态依赖。换句话说，`Singleton<MyClass>`的代码之所以能够被编译器实例化，是因为它不依赖于类`MyClass`的大小。只是在后来，当函数`Singleton<MyClass>::instance()`第1次被调用时，才需要类`MyClass`的大小，而此时编译器已经知道类`MyClass`的大小了。