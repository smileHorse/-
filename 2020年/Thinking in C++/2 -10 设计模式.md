# 2 -10 设计模式

​	设计模式的特点就是为了使工作更加容易。系统中总是有一些东西在变化 -- 这可能是在软件项目生命周期中代码的变化，或许是在某个程序执行的生命周期期间某些对象的变化。找出变化的东西，利用设计模式封装这些变化，并使这些变化能够得到控制。

​	仅仅做最简单的东西，不仅能够最快速的实现设计，而且其设计也很容易维护。如果这种最简单的东西不能完成工作，很快就会发现，除了花费时间编写复杂的实现方法之外，它们还是不起作用的。

## 1 模式的概念

​	最初，可以将模式看做解决某一类特定问题的特别巧妙和具有洞察力的方法。它体现出一支开发团队从一个问题的所有角度出发做出全面的分析后，提出的最通用最灵活的对这类问题的解决方案。

​	可以把模式的基本概念看做一般情况下程序设计的基本概念：增加一些抽象层。当人们对事物进行抽象的时候，隔离特定的细节，最直接的动机之一就是为了**使变化的事物和不变的事物分离开**。做到这一点的另一个方法是，一旦发现程序中的某些部分可能被修改，那么就要阻止那些修改在代码中导出传播副作用。如果做到了这一点，代码不仅比较容易阅读和理解，而且也比较容易维护，这样做就会带来一个注定的结果，就是在软件开发的全过程中降低成本。

​	开发一种优雅和可维护的软件设计最困难的部分，常常是发现所谓的**“变化向量”**。这就意味着寻找系统中变化的最重要的事物，换句话说，寻找系统中开发成本最高的地方。一旦找到这个**“变化向量”**，就可以围绕这个焦点来构建系统的设计。

​	因此，设计模式的目标是**封装变化**。

​	**对象组合优于类继承。一个似乎需要继承的设计常常能够戏剧性的使用组合来代替而大大简化，从而使其更灵活。因此，在考虑一个设计时，问问自己：“使用组合是不是更简单？这里真的需要继承吗？它能带来什么好处？”**

## 2 模式的分类

​	`GoF`讨论了23中模式，按照下面三种目的分类：

- **1 创建型(`Creational`)：**用于怎样创建一个对象。通常包括隔离对象创建的细节，这样代码不依赖于对象是什么类型，因此在增加一种新的对象类型时不需要改变代码。例如单例(`Singleton`)模式、工厂(`Factory`)模式和构建器(`Builder`)模式。
- **2 结构型(`Structural`)：**影响对象之间的连接方式，确保系统的变化不需要改变对象间的连接。结构型模式常常由工程项目限制条件来支配。例如代理(`Proxy`)模式和适配器(`Aaapter`)模式。
- **3 行为型(`Behavioral`)：**在程序中处理具有特定操作类型的对象。这些对象封装要执行的操作过程，比如解释一种语言、实践一个请求、遍历一个序列或者实现一种算法。例如命令(`Command`)模式、模板方法(`Template Method`)模式、状态(`State`)模式、策略(`Strategy`)模式、职责链(`Chain of Responsibility`)模式、观察者(`Observer`)模式、多派遣(`Multiple Dispatching`)模式和访问者(`Visitor`)模式。

## 3 单例

​	单例是允许一个类有且仅有一个实例的方法。

~~~c++
#include <iostream>
using namespace std;

class Singleton {
	static Singleton s;
	int i;
	Singleton(int x) : i(x) {}
	Singleton& operator=(const Singleton&);
	Singleton(const Singleton&);
public:
	static Singleton& instance() { return s; }
	int getValue() { return i; }
	void setValue(int x) { i = x; }
};

Singleton Singleton::s(47);

int main() {
	Singleton& s = Singleton::instance();
	cout << s.getValue() << endl;
	Singleton& s2 = Singleton::instance();
	s2.setValue(9);
	cout << s.getValue() << endl;
}
~~~

​	创建一个单例模式的关键是防止客户程序员获得任何控制其对象生存期的权利。为了做到这一点，声明所有的构造函数为私有，并且防止编译器隐式生成任何构造函数。拷贝构造函数和赋值操作符（故意没有实现，因为它们根本不会被调用）被声明为私有，以便防止任何这类复制动作的产生。

​	还必须决定如何去创建这个对象。在这里，它是被静态创建的。也可以等待，直到客户程序员提出要求再根据要求进行创建。这被称作惰性初始化，这种做法，只在创建对象的代价不大，并且并不总是需要它的情况下才有意义。

​	返回引用，而不是返回指针，是一种安全的实现方法。

​	**单例的变体**	

- 将在一个成员函数内部的静态对象的创建与单例类结合在一起：

~~~c++
class Singleton {
	int i;
	Singleton(int x) : i(x) {}
	Singleton& operator=(const Singleton&);
	Singleton(const Singleton&);
public:
	static Singleton& instance() { 
		static Singleton s(47);
		return s; 
	}
	int getValue() { return i; }
	void setValue(int x) { i = x; }
};
~~~

- 如果两个单件彼此依赖，就会产生一个特别有趣的情况：

~~~c++
class Singleton1 {
	Singleton1() {}
public:
	static Singleton1& ref() {
		static Singleton1 single;
		return single;
	}
};

class Singleton2 {
	Singleton1& s1;
	Singleton2(Singleton1& s) : s1(s) {}
public:
	static Singleton2& ref() {
		static Singleton2 single(Singleton1::ref());
		return single;
	}
	Singleton1& f() { return s1; }
};

int main() {
	Singleton1& s1 = Singleton2::ref().f();
}
~~~

​	当调用`Singleton2::ref()`时，它导致其唯一的`Singleton2`对象被创建。在这个对象的创建过程中，`Singleton1::ref()`被调用，这导致其唯一的`Singleton1`对象被创建。因为这种技术不依赖连接或装载的顺序，因此程序员能够很好的控制初始化的全过程，而导致较少的错误。

- 采用将一个对象的**单件属性**从其实现中分离出来的方法：

~~~c++
#include <iostream>
using namespace std;

template<class T> class Singleton {
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
protected:
	Singleton() {}
	virtual ~Singleton() {}
public:
	static T& instance() {
		static T theInstance;
		return theInstance;
	}
};

// A sample class to be made into a singleton
class MyClass : public Singleton<MyClass> {
	int x;
protected:
	friend class Singleton<MyClass>;
	MyClass() { x = 0; }
public:
	void setValue(int n) { x = n; }
	int getValue() const { return x; }
};

int main() {
	MyClass& m = MyClass::instance();
	cout << m.getValue() << endl;
	m.setValue(1);
	cout << m.getValue() << endl;
}
~~~

​	`MyClass`通过下面三个步骤产生一个单例：

1. 声明其构造函数为私有或保护的。
2. 声明类`Singleton<MyClass>`为友元。
3. 从`Singleton<MyClass>`派生出`MyClass`。

​	第三步中的自引用可能令人难以置信。这只是对模板`Singleton`中模板参数的静态依赖。换句话说，`Singleton<MyClass>`的代码之所以能够被编译器实例化，是因为它不依赖于类`MyClass`的大小。只是在后来，当函数`Singleton<MyClass>::instance()`第1次被调用时，才需要类`MyClass`的大小，而此时编译器已经知道类`MyClass`的大小了。

## 4 命令

​	命令模式就是一个函数对象：一个作为对象的函数。通过将函数封装为对象，就能够以参数的形式将其传递给其他函数或者对象，告诉它们在履行请求的过程中执行特定的操作。

​	命令模式的主要特点是允许向一个对象或函数传递一个想要的动作。

~~~c++
#include <iostream>
#include <vector>
using namespace std;

class Command {
public:
	virtual void execute() = 0;
};

class Hello : public Command {
public:
	void execute() { cout << "Hello " << endl; }
};

class World : public Command {
public:
	void execute() { cout << "World! " << endl; }
};

class IAm : public Command {
public:
	void execute() { cout << "I'm the command pattern" << endl; }
};

// An object that holds commands
class Macro {
	vector<Command*> commands;
public:
	void add(Command* c) { commands.push_back(c); }
	void run() {
		vector<Command*>::iterator it = commands.begin();
		while(it != commands.end()) {
			(*it++)->execute();
		}
	}
};

int main() {
	Macro macro;
	macro.add(new Hello);
	macro.add(new World);
	macro.add(new IAm);
	macro.run();
}
~~~

**利用命令模式消除与事件处理的耦合**

~~~c++
#include <iostream>
#include <vector>
#include <string>
#include <ctime>
#include <cstdlib>
using namespace std;

// Framework for running tasks
class Task {
public:
	virtual void operation() = 0;
};

class TaskRunner {
	static vector<Task*> tasks;
	TaskRunner() {}
	TaskRunner& operator=(const TaskRunner&);
	TaskRunner(const TaskRunner&);
	static TaskRunner tr;
public:
	static void add(Task& t) { tasks.push_back(&t); }
	static void run() {
		vector<Task*>::iterator it = tasks.begin();
		while(it != tasks.end()) {
			(*it++)->operation();
		}
	}
};

TaskRunner TaskRunner::tr;
vector<Task*> TaskRunner::tasks;

class EventSimulator {
	clock_t creation;
	clock_t delay;
public:
	EventSimulator() : creation(clock()) {
		delay = CLOCKS_PER_SEC / 4 * (rand() % 20 + 1);
		cout << "delay = " << delay << endl;
	}
	bool fired() {
		return clock() > creation + delay;
	}
};

// Something that can produce asynchronous events
class Button {
	bool pressed;
	string id;
	EventSimulator e;
public:
	Button(string name) : pressed(false), id(name) {}
	void press() { pressed = true; }
	bool isPressed() {
		if (e.fired()) {
			press();
		}
		return pressed;
	}
	friend ostream& operator<<(ostream& os, const Button& b) {
		return os << b.id;
	}
};

// The command object
class CheckButton : public Task {
	Button& button;
	bool handled;
public:
	CheckButton(Button& b) : button(b), handled(false) {}
	void operation() {
		if (button.isPressed() && !handled) {
			cout << button << " pressed" << endl;
			handled = true;
		}
	}
};

// The procedures that perform the main processing. These need to be 
// occasionally interrupted in order to check the state of the buttons 
// or other events
void procedure1() {
	TaskRunner::run();
};

void procedure2() {
	TaskRunner::run();
}

void procedure3() {
	TaskRunner::run();
}

int main() {
	srand(time(0));
	Button b1("Button 1"), b2("Button 2"), b3("Button 3");
	CheckButton cb1(b1), cb2(b2), cb3(b3);
	TaskRunner::add(cb1);
	TaskRunner::add(cb2);
	TaskRunner::add(cb3);
	cout << "Control-C to exit" << endl;
	while(true) {
		procedure1();
		procedure2();
		procedure3();
	}
}
~~~

​	在这里，`EventSimulator`创建一个随机延迟时间，所以当周期性地调用函数fired()时，在某个随机时间段，其返回结果从true到false变化。`EventSimulator`对象在类Button中使用，模拟在某个不可预知的时间段用户事件发生的动作。`CheckButton`是Task的实现，在程序中通过所有正常代码对其进行周期性的检查。

## 5 消除对象耦合

​	代理模式(Proxy)和状态模式(State)都提供一个代理类(Surrogate)。代码与代理类打交道，而做实际工作的类隐藏在代理类背后。这两种模式很相似，从结构上看，可以认为代理模式只是状态模式的一个特例。但这两个模式的内涵是不一样的。

​	基本思想是：代理类(Surrogate)派生自一个基类，由平行地派生自同一个基类的一个或多个类提供实际的实现。当一个代理对象被创建的时候，一个实现对象就分配给了它，代理对象就将函数调用发给实现对象。

​	代理模式和状态模式的区别：代理模式只有一个实现类，而状态模式有多个实现。`GoF`认为这两种设计模式的应用也不同：代理模式控制对其实现类的访问，而状态模式动态地改变其实现类。

### 5.1 代理模式：作为其他对象的前端

~~~c++
#include <iostream>
using namespace std;

class ProxyBase {
public:
	virtual void f() = 0;
	virtual void g() = 0;
	virtual void h() = 0;
	virtual ~ProxyBase() {}
};

class Implementation : public ProxyBase {
public:
	void f() { cout << "Implementation.f()" << endl; }
	void g() { cout << "Implementation.g()" << endl; }
	void h() { cout << "Implementation.h()" << endl; }
};

class Proxy : public ProxyBase {
	ProxyBase* implementation;
public:
	Proxy() { implementation = new Implementation(); }
	~Proxy() { delete implementation; }
	// Forward calls to the implementation
	void f() { implementation->f(); }
	void g() { implementation->g(); }
	void h() { implementation->h(); }
};

int main() {
	Proxy p;
	p.f();
	p.g();
	p.h();
}
~~~

​	某些情况下，Implementation并不需要与类Proxy具有相同的接口 -- Proxy类可以任意关联Implementation类并且将函数调用提交给它，这就符合了代理的基本思想。然而，使用共同的接口可以将代理的替代物插入到客户代码中 -- 编写客户代码只用来与原对象进行通信，不需要对其进行修改以接受代理。

​	代理模式的一般用途：

1. **远程代理(Remote Proxy)**。为不同地址空间的对象提供代理。通过某些远程对象技术实现。
2. **虚拟代理(Virtual Proxy)**。根据需要提供一种“惰性初始化”方式来创建高代价的对象。
3. **保护代理(Protection Proxy)**。当不愿意客户程序员拥有被代理对象的全部访问权限时，使用保护代理。
4. **巧妙引用(Smart reference)**。当访问被代理的对象时，增加额外的活动。引用计数就是一个例子。

### 5.2 状态模式：改变对象的行为

​	状态模式产生一个可以改变其类的对象，当发现在大多数或者所有函数中都存在有条件的代码时，这种模式很有用。在前端对象生存期期间，状态模式从一个实现对象到另一个实现对象进行切换，以实现对于相同的函数调用产生不同的行为。

~~~c++
#include <iostream>
#include <string>
using namespace std;

class Creature {
	class State {
	public: 
		virtual string response() = 0;
	};
	class Frog : public State {
	public:
		string response() { return "Ribbet!"; }
	};
	class Prince : public State {
	public:
		string response() { return "Darling!"; }
	};
	State* state;
public:
	Creature() : state(new Frog()) {}
	void greet() {
		cout << state->response() << endl;
	}
	void kiss() {
		delete state;
		state = new Prince();
	}
};

int main() {
	Creature creature;
	creature.greet();
	creature.kiss();
	creature.greet();
}
~~~

​	对状态类的改变会自动地在所有代码中进行传播，而不需要编辑这些类来完成改变。

## 6 适配器模式

​	适配器模式接受一种类型并且提供一个对其他类型的接口。当给定一个库或者具有某一接口的一段代码，同时还给定另外一个库或者与前面那段代码的基本思想相同的一段代码而只是表达方式不一致时，适配器模式将十分有用。通过调整彼此的表达方式以适配彼此，将会迅速产生解决办法。

~~~c++
#ifndef FIBONACCIGENERATOR_H
#define FIBONACCIGENERATOR_H

class FibonacciGenerator {
	int n;
	int val[2];
public:
	FibonacciGenerator() : n(0) { val[0] = val[1] = 0; }
	int operator()() {
		int result = n > 2 ? val[0] + val[1] : n > 0 ? 1 : 0;
		++n;
		val[0] = val[1];
		val[1] = result;
		return result;
	}
	int count() { return n; }
};
#endif
~~~

~~~c++
// Adapting an interface to something you already have
#include <iostream>
#include <numeric>
#include "FibonacciGenerator.h"
using namespace std;

class FibonacciAdapter {
	FibonacciGenerator f;
	int length;
public:
	FibonacciAdapter(int size) : length(size) {}
	class iterator;
	friend class iterator;
	class iterator : public std::iterator<std::input_iterator_tag, FibonacciAdapter, ptrdiff_t> {
		FibonacciAdapter& ap;
	public:
		typedef int value_type;
		iterator(FibonacciAdapter& a) : ap(a) {}
		bool operator==(const iterator&) const {
			return ap.f.count() == ap.length;
		}
		bool operator!=(const iterator& x) const {
			return !(*this == x);
		}
		int operator*() const { return ap.f(); }
		iterator& operator++() { return *this; }
		iterator& operator++(int) { return *this; } 
	};
	iterator begin() { return iterator(*this); }
	iterator end() { return iterator(*this); }
};

int main() {
	const int SZ = 20;
	FibonacciAdapter a1(SZ);
	cout << "accumulate: " << accumulate(a1.begin(), a1.end(), 0) << endl;
	FibonacciAdapter a2(SZ), a3(SZ);
	cout << "inner product: " << inner_product(a2.begin(), a2.end(), a3.begin(), 0) << endl;
	FibonacciAdapter a4(SZ);
	int r1[SZ] = {0};
	int* end = partial_sum(a4.begin(), a4.end(), r1);
	FibonacciAdapter a5(SZ);
	int r2[SZ] = {0};
	end = adjacent_difference(a5.begin(), a5.end(), r2);
}
~~~

## 7 模板方法模式

​	模板方法模式的一个重要特征是它的定义在基类中(有时作为一个私有成员函数)并且不能改动 -- 模板方法模式就是坚持相同的代码。它调用其他基类函数(就是那些被覆盖的函数)以便完成其工作，但是客户程序员不必直接调用这些函数。

~~~c++
#include <iostream>
using namespace std;

class ApplicationFramework {
protected:
	virtual void customize1() = 0;
	virtual void customize2() = 0;
public:
	void templateMethod() {
		for (int i = 0; i < 5; ++i){
			customize1();
			customize2();
		}
	}
};

// Create a new Application
class MyApp : public ApplicationFramework {
protected:
	virtual void customize1() { cout << "Hello "; }
	virtual void customize2() { cout << "World!" << endl; }
};

int main() {
	MyApp app;
	app.templateMethod();
}
~~~

## 8 策略模式

​	模板方法模式是“坚持相同的代码”，而被覆盖的函数是“变化的代码”。然而，这种变化在编译时通过继承被固定下来。按照“组合优于继承”的格言，可以利用组合来解决将变化的代码从“坚持相同的代码”中分开的问题，从而产生策略模式。这种方法有一个明显的好处：在程序运行时，可以插入变化的代码。策略模式也加入了“语境”，它可以是一个代理类，这个类控制着对特定策略对象的选择和使用 -- 就像状态模式一样。

​	策略的意思就是：可以使用多种方法来解决某个问题。例如：

~~~c++
#include <iostream>
using namespace std;

class NameStrategy {
public:
	virtual void greet() = 0;
};

class SayHi : public NameStrategy {
public:
	void greet() {
		cout << "Hi!How's it going?" << endl;
	}
};

class Ignore : public NameStrategy {
public:
	void greet() {
		cout << "Pretend I don't see you" << endl;
	}
};

class Admission : public NameStrategy {
public:
	void greet() {
		cout << "I'm sorry, I forgot your name" << endl;
	}
};

class Context {
	NameStrategy& strategy;
public:
	Context(NameStrategy& strat) : strategy(strat) {}
	void greet() { strategy.greet(); }
};

int main() {
	SayHi sayHi;
	Ignore ignore;
	Admission admission;
	Context c1(sayHi), c2(ignore), c3(admission);
	c1.greet();
	c2.greet();
	c3.greet();
}
~~~

## 9 职责链模式 - 尝试使用一系列策略模式

​	职责链模式也许被看作一个使用策略对象的“递归地动态一般化”。此时提出一个调用，在一个链表序列中的每个策略都试图满足这个调用。这个过程直到有一个策略成功满足该调用或者到达链表序列的末尾才结束。在职责链中，一个函数调用自身，通过遍历策略链表调用函数的一个不同实现，如此反复直至到达某个终止条件。这个终止条件或者是已到达策略链表的尾部（这样就会返回一个默认对象；不管能否提供这个默认结果，必须有个方法能够决定职责链搜索是成功还是失败）或者是成功找到一个策略。

~~~C++
#include <iostream>
#include <vector>
using namespace std;

enum Answer { NO, YES };

class GimmeStrategy {
public:
	virtual Answer canIHave() = 0;
	virtual ~GimmeStrategy() {}
};

class AskMom : public GimmeStrategy {
public:
	Answer canIHave() {
		cout << "Mooom? Can I have this?" << endl;
		return NO;
	}
};

class AskDad : public GimmeStrategy {
public:
	Answer canIHave() {
		cout << "Dad, I really need this!" << endl;
		return NO;
	}
};

class AskGrandpa : public GimmeStrategy {
public:
	Answer canIHave() {
		cout << "Grandpa, is it my birthday yet?" << endl;
		return NO;
	}
};

class AskGrandma : public GimmeStrategy {
public:
	Answer canIHave() {
		cout << "Grandma, I really love you!" << endl;
		return YES;
	}
};

class Gimme : public GimmeStrategy {
	vector<GimmeStrategy*> chain;
public:
	Gimme() {
		chain.push_back(new AskMom());
		chain.push_back(new AskDad());
		chain.push_back(new AskGrandpa());
		chain.push_back(new AskGrandma());
	}
	Answer canIHave() {
		vector<GimmeStrategy*>::iterator it = chain.begin();
		while(it != chain.end()) {
			if ((*it++)->canIHave() == YES) {
				return YES;
			}
		}
		cout << "Whiiiiiinne!" << endl;
		return NO;
	}
	~Gimme() {}
};

int main() {
	Gimme chain;
	chain.canIHave();
}
~~~

​	上面示例中的内容与`GoF`中关于职责链的那部分内容有明显不一致的地方，因为它们专注于创建自己的链表。牢记职责链的本质是尝试多个解决方案直到找到一个起作用的方法。

## 10 工厂模式：封装对象的创建

​	实现工厂模式的一种方法就是在基类中定义一个静态成员函数：

~~~c++
#include <iostream>
#include <stdexcept>
#include <cstddef>
#include <string>
#include <vector>
using namespace std;

class Shape {
public:
	virtual void draw() = 0;
	virtual void erase() = 0;
	virtual ~Shape() {}
	class BadShapeCreation : public logic_error {
	public:
		BadShapeCreation(string type)
			: logic_error("Cannot create type " + type) {}
	};
	static Shape* factory(const string& type) throw(BadShapeCreation);
};

class Circle : public Shape {
	Circle() {}
	friend class Shape;
public:
	void draw() { cout << "Circle::draw" << endl; }
	void erase() { cout << "Circle::erase" << endl; }
	~Circle() { cout << "Circle::~Circle" << endl; }
};

class Square : public Shape {
	Square() {}
	friend class Shape;
public:
	void draw() { cout << "Square::draw" << endl; }
	void erase() { cout << "Square::erase" << endl; }
	~Square() { cout << "Square::~Circle" << endl; }
};

Shape* Shape::factory(const string& type) throw(BadShapeCreation) {
	if (type == "Circle") return new Circle;
	if (type == "Square") return new Square;
	throw BadShapeCreation(type);
}

char* sl[] = { "Circle", "Square", "Square", "Circle", "Circle", "Circle", "Square" };
int main() {
	vector<Shape*> shapes;
	try {
		for (size_t i = 0; i < sizeof sl / sizeof sl[0]; ++i) {
			shapes.push_back(Shape::factory(sl[i]));
		} 
	} catch(Shape::BadShapeCreation e) {
		cout << e.what() << endl;
		return EXIT_FAILURE;
	}
	for (size_t i = 0; i < shapes.size(); ++i) {
		shapes[i]->draw();
		shapes[i]->erase();
	}
}
~~~

​	为了确保对象的创建只能发生在函数`factory()`中，Shape的特定类型的构造函数被设为私有，同时Shape被声明为友元类，因此`factory()`能够访问这些构造函数。这样的设计还有另外一个重要的含义 --  基类Shape现在必须了解每个派生类的细节 --  这是面向对象设计试图避免的一个性质。对于结构框架或者任何类库来说都应该支持扩充，但这样一来，系统很快会变得很笨拙，因为一旦新类型被添加到这种层次结构中，基类就必须更新。可以使用下一小节讨论的多态工厂来避免这种循环依赖。

### 10. 1 多态工厂

​	`GoF`强调工厂方法模式的理由是，可以使不同类型的工厂派生自基本类型的工厂。工厂方法模式事实上是多态工厂模式的一个特例。

~~~c++
#include <iostream>
#include <map>
#include <stdexcept>
#include <cstddef>
#include <string>
#include <vector>
using namespace std;

class Shape {
public:
	virtual void draw() = 0;
	virtual void erase() = 0;
	virtual ~Shape() {}
};

class ShapeFactory {
	virtual Shape* create() = 0;
	static map<string, ShapeFactory*> factories;
public:
	virtual ~ShapeFactory() {}
	friend class ShapeFactoryInitializer;
	class BadShapeCreation : public logic_error {
	public:
		BadShapeCreation(string type)
			: logic_error("Cannot create type " + type) {}
	};
	static Shape* createShape(const string& id) throw (BadShapeCreation) {
		if (factories.find(id) != factories.end()) {
			return factories[id]->create();
		} else {
			throw BadShapeCreation(id);
		}
	}
};
map<string, ShapeFactory*> ShapeFactory::factories;

class Circle : public Shape {
	Circle() {}
	friend class ShapeFactoryInitializer;
	class Factory;
	friend class Factory;
	class Factory : public ShapeFactory {
	public:
		Shape* create() { return new Circle; }
		friend class ShapeFactoryInitializer;
	};
public:
	void draw() { cout << "Circle::draw" << endl; }
	void erase() { cout << "Circle::erase" << endl; }
	~Circle() { cout << "Circle::~Circle" << endl; }
};

class Square : public Shape {
	Square() {}
	friend class ShapeFactoryInitializer;
	class Factory;
	friend class Factory;
	class Factory : public ShapeFactory {
	public:
		Shape* create() { return new Square; }
		friend class ShapeFactoryInitializer;
	};
public:
	void draw() { cout << "Square::draw" << endl; }
	void erase() { cout << "Square::erase" << endl; }
	~Square() { cout << "Square::~Circle" << endl; }
};

// Signleton to initialize the ShapeFactory
class ShapeFactoryInitializer {
	static ShapeFactoryInitializer si;
	ShapeFactoryInitializer() {
		ShapeFactory::factories["Circle"] = new Circle::Factory();
		ShapeFactory::factories["Square"] = new Square::Factory();
	}
	~ShapeFactoryInitializer() {
		map<string, ShapeFactory*>::iterator it = ShapeFactory::factories.begin();
		while(it != ShapeFactory::factories.end())
			delete it++->second;
	}
};
ShapeFactoryInitializer ShapeFactoryInitializer::si;

char* sl[] = { "Circle", "Square", "Square", "Circle", "Circle", "Circle", "Square" };
int main() {
	vector<Shape*> shapes;
	try {
		for (size_t i = 0; i < sizeof sl / sizeof sl[0]; ++i) {
			shapes.push_back(ShapeFactory::createShape(sl[i]));
		} 
	} catch(ShapeFactory::BadShapeCreation e) {
		cout << e.what() << endl;
		return EXIT_FAILURE;
	}
	for (size_t i = 0; i < shapes.size(); ++i) {
		shapes[i]->draw();
		shapes[i]->erase();
	}
}
~~~

​	工厂方法模式作为`virtual create()`出现在它自己的`ShapeFactory`类中。这是一个私有成员函数，意味着不能直接调用它，但可以被覆盖。Shape的子类必须创建各自的`ShapeFactory`子类，并且覆盖成员函数`create()`以创建其自身类型的对象。这些工厂是私有的，只能被主工厂方法模式访问。采用这种方法，所有客户代码都必须通过工厂方法模式创建对象。

​	`ShapeFactory`必须通过装载它的map与工厂对象进行初始化，这些操作发生在单件`ShapeFactoryInitializer`中。当增加一个新类型到这个设计时，必须定义该类型，创建一个工厂并修改`ShapeFactoryInitializer`，以便将工厂的一个实例插入map中。这些额外的复杂操作再次暗示，如果不需要创建独立的工厂对象，尽可能使用静态工厂方法模式。

### 10.2 抽象工厂

​	抽象工厂模式看起来和工厂方法很相似，只是它使用若干工厂方法模式。每个工厂方法模式创建一个不同类型的对象。当创建一个工厂对象时，要决定将如何使用由那个工厂创建的所有对象。

~~~c++
#include <iostream>
using namespace std;

class Obstacle {
public:
	virtual void action() = 0;
};

class Player {
public:
	virtual void interactWith(Obstacle*) = 0;
};

class Kitty : public Player {
	virtual void interactWith(Obstacle* ob) {
		cout << "Kitty has encountered a ";
		ob->action();
	}
};

class KungFuGuy : public Player {
	virtual void interactWith(Obstacle* ob) {
		cout << "KungFuGuy now battles against a ";
		ob->action();
	}
};

class Puzzle : public Obstacle {
public:
	void action() { cout << "Puzzle" << endl; }
};

class NastyWeapon : public Obstacle {
public:
	void action() { cout << "NastyWeapon" << endl; }
};

// The abstract factory
class GameElementFactory {
public:
	virtual Player* makePlayer() = 0;
	virtual Obstacle* makeObstacle() = 0;
};

// Concrete factories
class KittiesAndPuzzles : public GameElementFactory {
public:
	virtual Player* makePlayer() { return new Kitty(); }
	virtual Obstacle* makeObstacle() { return new Puzzle(); }
};

class KillAndDismember : public GameElementFactory {
public:
	virtual Player* makePlayer() { return new KungFuGuy(); }
	virtual Obstacle* makeObstacle() { return new NastyWeapon(); }
};

class GameEnvironment {
	GameElementFactory* gef;
	Player* p;
	Obstacle* ob;
public:
	GameEnvironment(GameElementFactory* factory)
		: gef(factory), p(factory->makePlayer()), ob(factory->makeObstacle()) {}
	void play() { p->interactWith(ob); }
	~GameEnvironment() {
		delete p;
		delete ob;
		delete gef;
	}
};

int main() {
	GameEnvironment g1(new KittiesAndPuzzles), g2(new KillAndDismember);
	g1.play();
	g2.play();
}
~~~

### 10.3 虚构造函数

​	使用工厂方式模式的主要目标之一就是更好地组织代码，使得在创建对象时不需要选择准确的构造函数类型。也就是说，可以告诉工厂：“现在还不能确切地知道需要什么类型的对象，但是这里有一些信息，请创建类型适当的对象。”

​	在构造函数调用期间，虚拟机制并不起作用。因为当在构造函数内部调用虚函数时，将由虚函数决定指向哪个“局部的”函数体。

​	如果想在构造函数中调用虚函数，并使其完成正确地工作，必须使用某种技术来模拟虚构造函数。虚构造函数好像是在对一个对象说：“我不能准确知道你是什么类型的对象，但是无论如何要以正确地类型建造你。”

​	`Coplien`将他给出的解决此问题的方法取名为“信封和信件类”。信封类是基类，它是一个包含指向一个对象的指针的外壳，该对象也是一个基类类型。信封类的构造函数决定采用什么样的特定类型，在堆上创建一个该类型的对象，然后对它的指针分配对象（决定是在运行中调用构造函数时做出的，而不是在编译中做类型正常检查时做出的）。随后的所有函数调用都是由基类通过它的指针来进行处理。这实际上就是状态模式的小小变形，其中基类扮演派生类的代理的角色，而派生类提供行为中的变化：

~~~c++
#include <iostream>
#include <stdexcept>
#include <cstddef>
#include <string>
#include <vector>
using namespace std;

class Shape {
	Shape* s;
	// prevent copy-construction & operator=
	Shape(const Shape&);
	Shape& operator=(const Shape&);
protected:
	Shape() { s = 0; }
public:
	virtual void draw() { s->draw(); }
	virtual void erase() { s->erase(); }
	virtual void test() { s->test(); }
	virtual ~Shape() {
		cout << "~Shape" << endl;
		if (s) {
			cout << "Making virtual call: ";
			s->erase();
		}
		cout << "delete s: ";
		delete s;
	}
	class BadShapeCreation : public logic_error {
	public:
		BadShapeCreation(string type)
			: logic_error("Cannot create type " + type) {}
	};
	Shape(string type) throw(BadShapeCreation);
};

class Circle : public Shape {
	Circle(Circle&);
	Circle& operator=(Circle&);
	Circle() {}
	friend class Shape;
public:
	void draw() { cout << "Circle::draw" << endl; }
	void erase() { cout << "Circle::erase" << endl; }
	void test() { draw(); }
	~Circle() { cout << "Circle::~Circle" << endl; }
};

class Square : public Shape {
	Square(Square&);
	Square& operator=(Square&);
	Square() {}
	friend class Shape;
public:
	void draw() { cout << "Square::draw" << endl; }
	void erase() { cout << "Square::erase" << endl; }
	void test() { draw(); }
	~Square() { cout << "Square::~Circle" << endl; }
};

Shape::Shape(string type) throw(BadShapeCreation) {
	if (type == "Circle") s = new Circle;
	else if (type == "Square") s = new Square;
	else throw BadShapeCreation(type);
	draw();
}

char* sl[] = { "Circle", "Square", "Square", "Circle", "Circle", "Circle", "Square" };
int main() {
	vector<Shape*> shapes;
	cout << "virtual constructor calls:" << endl;
	try {
		for (size_t i = 0; i < sizeof sl / sizeof sl[0]; ++i) {
			shapes.push_back(new Shape(sl[i]));
		} 
	} catch(Shape::BadShapeCreation e) {
		cout << e.what() << endl;
		return EXIT_FAILURE;
	}
	for (size_t i = 0; i < shapes.size(); ++i) {
		shapes[i]->draw();
		cout << "test" << endl;
		shapes[i]->test();
		cout << "end test" << endl;
		shapes[i]->erase();
	}
	Shape c("Circle");
	cout << "destructor calls:" << endl;
}
~~~

​	基类Shape包含一个对象指针作为其唯一的数据成员，该指针指向Shape类型的对象。在创建一个“虚构造函数”模式时，务必确保这个指针总是被初始化成指向一个激活的对象。这个基类实际上就是一个代理，因为这是客户程序唯一所能看到和与之交互的对象。

​	在这种模式中，默认构造函数有一个重要的工作要做 --  它必须将指针s设置为零值。如果不调用默认构造函数把s赋为零值，将会出现问题。虚构造函数使用其参数提供的信息，这些信息完全能够决定对象的类型。注意，这些类型信息在运行时才能读取和使用，而在一般情况下，编译器在编译时必须知道确切的类型。

​	虚构造函数使用其参数来选择要构造的实际对象（“信件”），然后对“信封”内的指针赋值。至此，“信件”类对象创建完成，因此任何虚函数的调用得以正确地重定向。

​	这是一个很复杂的方法，所以隐藏构造的最常见的工具一般是普通的“工厂方法”而不是“虚构造函数”模式这样的方法。

## 11 构建器模式：创建复杂对象

​	构建器模式的目标是将对象的创建与它的“表示法”分开。这就意味着，创建过程保持原状，但是产生对象的表示法可能不同。`GoF`指出，构建器模式和抽象工厂模式主要的区别就是，构建器模式一步步的创建对象，所以及时展开输出创建过程就似乎很重要。此外，“主管（director）”获得一个切片的流(stream)，并且将这些切片传递给构建器，每个切片用来执行创建过程的一步。

​	举个例子，作为模型的一辆自行车按照其类型（山地车、旅行车、赛车）来选择零部件来组件一辆自行车。一个构建器与每个自行车类都关联，每个构建器实现的接口由抽象类`BicycleBuilder`中指定。单独的类`BicycleTechnician`表示`GoF`中描述的“导向器”对象，它使用具体的`BicycleBuilder`对象来构造`Bicycle`对象。

`Bicycle.h:`

~~~c++
#ifndef BICYCLE_H
#define BICYCLE_H

#include <iostream>
#include <string>
#include <vector>
#include <cstddef>
using namespace std;

class BicyclePart {
public:
	enum BPart { FRAME, WHEEL, SEAT, DERAILLEUR, HANDLEBAR, SPROCKET, RACK, SHOCK, NPARTS };
private:
	BPart id;
	static string names[NPARTS];
public:
	BicyclePart(BPart bp) { id = bp; }
	friend ostream& operator<<(ostream& os, const BicyclePart& bp) {
		return os << bp.names[bp.id];
	}
};

class Bicycle {
	vector<BicyclePart*> parts;
public:
	~Bicycle() {}
	void addPart(BicyclePart* bp) { parts.push_back(bp); }
	friend ostream& operator<<(ostream& os, const Bicycle& b) {
		os << "{ ";
		for (size_t i = 0; i < b.parts.size(); ++i) {
			os << *b.parts[i] << " ";
		}
		return os << "}";
	}
};

class BicycleBuilder {
protected:
	Bicycle* product;
public:
	BicycleBuilder() { product = 0; }
	void createProduct() { product = new Bicycle; }
	virtual void buildFrame() = 0;
	virtual void buildWheel() = 0;
	virtual void buildSeat() = 0;
	virtual void buildDerailleur() = 0;
	virtual void buildHandlebar() = 0;
	virtual void buildSprocket() = 0;
	virtual void buildRack() = 0;
	virtual void buildShock() = 0;
	virtual string getBikeName() const = 0;
	Bicycle* getProduct() {
		Bicycle* temp = product;
		product = 0;	// Relinquish product
		return temp;
	}
};

class MountainBikeBuilder : public BicycleBuilder {
public:
	void buildFrame();
	void buildWheel();
	void buildSeat();
	void buildDerailleur();
	void buildHandlebar();
	void buildSprocket();
	void buildRack();
	void buildShock();
	string getBikeName() const { return "MountainBike"; }
};

class TouringBikeBuilder : public BicycleBuilder {
public:
	void buildFrame();
	void buildWheel();
	void buildSeat();
	void buildDerailleur();
	void buildHandlebar();
	void buildSprocket();
	void buildRack();
	void buildShock();
	string getBikeName() const { return "TouringBike"; }
};

class RacingBikeBuilder : public BicycleBuilder {
public:
	void buildFrame();
	void buildWheel();
	void buildSeat();
	void buildDerailleur();
	void buildHandlebar();
	void buildSprocket();
	void buildRack();
	void buildShock();
	string getBikeName() const { return "RacingBike"; }
};

class BicycleTechnician {
	BicycleBuilder* builder;
public:
	BicycleTechnician() { builder = 0; }
	void setBuilder(BicycleBuilder* b) { builder = b; }
	void construct();
};

#endif
~~~

​	由一个`BicycleTechnician`调用派生的`BicycleBuilder`对象的函数`createProduct()`来初始化一辆自行车的创建。`BicycleTechnician::constructor()`函数调用`BicycleBuilder`接口中的所有函数。

`Bicycle.cpp:`

~~~c++
#include "Bicycle.h"
#include <cassert>
#include <cstddef>

string BicyclePart::names[] = {
	"Frame", "Wheel", "Seat", "Derailleur",
	"Handlebar", "Sprocket", "Rack", "Shock"
};

void MountainBikeBuilder::buildFrame() {
	product->addPart(new BicyclePart(BicyclePart::FRAME));
}

void MountainBikeBuilder::buildWheel() {
	product->addPart(new BicyclePart(BicyclePart::WHEEL));
}

void MountainBikeBuilder::buildSeat() {
	product->addPart(new BicyclePart(BicyclePart::SEAT));
}

void MountainBikeBuilder::buildDerailleur() {
	product->addPart(new BicyclePart(BicyclePart::DERAILLEUR));
}

void MountainBikeBuilder::buildHandlebar() {
	product->addPart(new BicyclePart(BicyclePart::HANDLEBAR));
}

void MountainBikeBuilder::buildSprocket() {
	product->addPart(new BicyclePart(BicyclePart::SPROCKET));
}

void MountainBikeBuilder::buildRack() {}

void MountainBikeBuilder::buildShock() {
	product->addPart(new BicyclePart(BicyclePart::SHOCK));
}

void TouringBikeBuilder::buildFrame() {
	product->addPart(new BicyclePart(BicyclePart::FRAME));
}

void TouringBikeBuilder::buildWheel() {
	product->addPart(new BicyclePart(BicyclePart::WHEEL));
}

void TouringBikeBuilder::buildSeat() {
	product->addPart(new BicyclePart(BicyclePart::SEAT));
}

void TouringBikeBuilder::buildDerailleur() {
	product->addPart(new BicyclePart(BicyclePart::DERAILLEUR));
}

void TouringBikeBuilder::buildHandlebar() {
	product->addPart(new BicyclePart(BicyclePart::HANDLEBAR));
}

void TouringBikeBuilder::buildSprocket() {
	product->addPart(new BicyclePart(BicyclePart::SPROCKET));
}

void TouringBikeBuilder::buildRack() {
	product->addPart(new BicyclePart(BicyclePart::RACK));
}

void TouringBikeBuilder::buildShock() {}

void RacingBikeBuilder::buildFrame() {
	product->addPart(new BicyclePart(BicyclePart::FRAME));
}

void RacingBikeBuilder::buildWheel() {
	product->addPart(new BicyclePart(BicyclePart::WHEEL));
}

void RacingBikeBuilder::buildSeat() {
	product->addPart(new BicyclePart(BicyclePart::SEAT));
}

void RacingBikeBuilder::buildDerailleur() {}

void RacingBikeBuilder::buildHandlebar() {
	product->addPart(new BicyclePart(BicyclePart::HANDLEBAR));
}

void RacingBikeBuilder::buildSprocket() {
	product->addPart(new BicyclePart(BicyclePart::SPROCKET));
}

void RacingBikeBuilder::buildRack() {}

void RacingBikeBuilder::buildShock() {}

void BicycleTechnician::construct() {
	assert(builder);
	builder->createProduct();
	builder->buildFrame();
	builder->buildWheel();
	builder->buildSeat();
	builder->buildDerailleur();
	builder->buildHandlebar();
	builder->buildSprocket();
	builder->buildRack();
	builder->buildShock();
}
~~~

`BuildBicycles.cpp:`

~~~c++
#include <cstddef>
#include <iostream>
#include <map>
#include <vector>
#include "Bicycle.h"
using namespace std;

// Constructs a bike via a concreate builder
Bicycle* buildMeABike(BicycleTechnician& t, BicycleBuilder* builder) {
	t.setBuilder(builder);
	t.construct();
	Bicycle* b = builder->getProduct();
	cout << "Built a " << builder->getBikeName() << endl;
	return b;
}

int main() {
	map<string, size_t> order;
	order["mountain"] = 2;
	order["touring"] = 1;
	order["racing"] = 3;

	vector<Bicycle*> bikes;
	BicycleBuilder* m = new MountainBikeBuilder;
	BicycleBuilder* t = new TouringBikeBuilder;
	BicycleBuilder* r = new RacingBikeBuilder;
	BicycleTechnician tech;
	map<string, size_t>::iterator it = order.begin();
	while(it != order.end()) {
		BicycleBuilder* builder;
		if (it->first == "mountain") {
			builder = m;
		} else if (it->first == "touring") {
			builder = t;
		} else if (it->first == "racing") {
			builder = r;
		}
		for (size_t i = 0; i < it->second; ++i)	{
			bikes.push_back(buildMeABike(tech, builder));
		}
		++it;
	}
	delete m;
	delete t;
	delete r;

	for (size_t i = 0; i < bikes.size(); ++i) {
		cout << "Bicycle: " << *bikes[i] << endl;
	}
}
~~~

## 12 观察者模式

​	观察者模式用于解决一个相当常见的问题：当某些其他对象改变状态时，如果一组对象需要进行相应的更新，那么应该如何处理？

​	下面的例子中使用两种对象的类型以实现观察者模式。类`Observable`跟踪那些当一类对象发生某种变化时需要被通知的对象。类`Observable`为列表上的每个观察者调用成员函数`notifyObservers()`。成员函数`notifyObservers()`是基类`Observable`的一部分。

​	在观察者模式中有两个“变化的事件”：正在进行观察的对象的数量和更新发生的方式。这就是说，观察者模式允许修改这二者而不影响周围的其他代码。

`Observer.h:`

~~~c++
#ifndef OBSERVER_H
#define OBSERVER_H

class Observable;
class Argument {};

class Observer {
public:
	// Called by the observed object, whenever the observerd object is changed
	virtual void update(Observable* o, Argument* arg) = 0;
	virtual ~Observer() {}
};
#endif
~~~

`Observable.h:`

~~~c++
#ifndef OBSERVABLE_H
#define OBSERVABLE_H

#include <set>
#include "Observer.h"
using namespace std;

class Observable {
	bool changed;
	set<Observer*> observers;
protected：
	virtual void setChanged() { changed = true; }
	virtual void clearChanged() { changed = false; }
public:
	virtual void addObserver(Observer& o) {
		observers.insert(&o);
	}
	virtual void deleteObserver(Observer& o) {
		observers.erase(&o);
	}
	virtual void deleteObservers() {
		observers.clear();
	}
	virtual int countObservers() {
		return observers.size();
	}
	virtual bool hasChanged() { return changed; }
	// If this object has changed, notify all of its observers
	virtual void notifyObservers(Argument* arg = 0) {
		if (!hasChanged())	{ return; }
		clearChanged();
		set<Observer*>::iterator it;
		for(it = observers.begin(); it != observers.end(); ++it) {
			(*it)->update(this, arg);
		}
	}
	virtual ~Observable() {}
};

#endif
~~~

​	类`Argument`是空的，在更新过程中它只担任一个基类的角色，用于传递需要的任何参数类型。如果需要，也可以仅传递额外的像`void*`类型这样的参数。这两种情况下无论哪种都有向下类型转换的操作。

​	`Observer::update()`函数在被观察的对象认为到了更新其所有观察者的时机时被调用。传递的参数为引起更新操作的对象和任何额外的有用信息。

​	起初似乎可以使用一个普通的`Observable`对象来管理更新操作，但这不会起作用；为了使之生效，必须从`Observable`派生出子类并且在派生类的代码中某处调用函数`setChanged()`。当调用`notifyObservers()`时，所有的观察者都将得到通知。在哪里调用`setChanged()`取决于程序的逻辑设计。

### 12.1 “内部类”方法

​	在某些情况下，必须有效的向上类型转换成为多个不同的类型，但是在这种情况下，需要为同一个基类类型提供几个不同的实现。从Java中引入了内部类的内建特征，很像`C++`的嵌套类，但比嵌套类更优越。它能够通过隐式使用内部类创建的对象的“this”指针来访问其外围类的非静态数据成员。

`InnerClassIdiom.cpp:`

~~~c++
#include <iostream>
#include <string>
using namespace std;

class Poingable {
public:
	virtual void poing() = 0;
};

void callPoing(Poingable& p) {
	p.poing();
}

class Bingable {
public:
	virtual void bing() = 0;
};

void callBing(Bingable& b) {
	b.bing();
}

class Outer {
	string name;
	class Inner1;
	friend class Outer::Inner1;
	class Inner1 : public Poingable {
		Outer* parent;
	public:
		Inner1(Outer* p) : parent(p) {}
		void poing() {
			cout << "poing called for " << parent->name << endl;
		}
	} inner1;

	class Inner2;
	friend class Outer::Inner2;
	class Inner2 : public Bingable {
		Outer* parent;
	public:
		Inner2(Outer* p) : parent(p) {}
		void bing() {
			cout << "bing called for " << parent->name << endl;
		}
	} inner2;
public:
	Outer(const string& nm) : name(nm), inner1(this), inner2(this) {}
	operator Poingable&() { return inner1; }
	operator Bingable&() { return inner2; }
};

int main() {
	Outer x("Ping Pong");
	callPoing(x);
	callBing(x);
}
~~~

​	类`Outer`同时提供`Poingable`和`Bingable`两个接口，这样它就能同`callPoing()`和`callBing()`一起使用。嵌套类有一个指向用于创建`Outer`对象的指针，这个指针必须在嵌套类的构造函数中进行初始化。

​	注意，两个内部类都是private的，事实上客户代码都不能访问其任何实现细节，因为两个访问函数`operator Poingable&()`和`operator Bingable&()`只返回一个用来向上类型转换为接口的引用，而不是实现它的对象。事实上，因为两个类都是private的，客户代码甚至不能向下类型转换为实现类，这样就在接口和实现之间提供了完全的隔离。

### 12.2 观察者模式举例

`ObservedFlower.cpp:`

~~~c++
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>
#include "Observable.h"
using namespace std;

class Flower {
	bool isOpen;
public:
	Flower() : isOpen(false), openNotifier(this), closeNotifier(this) {}
	void open() {
		isOpen = true;
		openNotifier.notifyObservers();
		closeNotifier.open();
	}
	void close() {
		isOpen = false;
		closeNotifier.notifyObservers();
		openNotifier.close();
	}

	class OpenNotifier;
	friend class Flower::OpenNotifier;
	class OpenNotifier : public Observable {
		Flower* parent;
		bool alreadyOpen;
	public:
		OpenNotifier(Flower* f) : parent(f), alreadyOpen(false) {}
		void notifyObservers(Argument* arg = 0) {
			if (parent->isOpen && !alreadyOpen) {
				setChanged();
				Observable::notifyObservers();
				alreadyOpen = true;
			}
		}
		void close() { alreadyOpen = false; }
	} openNotifier;

	class CloseNotifier;
	friend class Flower::CloseNotifier;
	class CloseNotifier : public Observable {
		Flower* parent;
		bool alreadyClosed;
	public:
		CloseNotifier(Flower* f) : parent(f), alreadyClosed(false) {}
		void notifyObservers(Argument* arg = 0) {
			if (!parent->isOpen && !alreadyClosed) {
				setChanged();
				Observable::notifyObservers();
				alreadyClosed = true;
			}
		}
		void open() { alreadyClosed = false; }
	} closeNotifier;
};

class Bee {
	string name;
	class OpenObserver;
	friend class Bee::OpenObserver;
	class OpenObserver : public Observer {
		Bee* parent;
	public:
		OpenObserver(Bee* b) : parent(b) {}
		void update(Observable* o, Argument* arg) {
			cout << "Bee " << parent->name << "'s breakfast time" << endl;
		}
	} openObsrv;

	class CloseObserver;
	friend class Bee::CloseObserver;
	class CloseObserver : public Observer {
		Bee* parent;
	public:
		CloseObserver(Bee* b) : parent(b) {}
		void update(Observable* o, Argument* arg) {
			cout << "Bee " << parent->name << "'s bed time!" << endl;
		}
	} closeObsrv;
public:
	Bee(string nm) : name(nm), openObsrv(this), closeObsrv(this) {}
	Observer& openObserver() { return openObsrv; }
	Observer& closeObserver() { return closeObsrv; }
};

class Hummingbird {
	string name;
	class OpenObserver;
	friend class Hummingbird::OpenObserver;
	class OpenObserver : public Observer {
		Hummingbird* parent;
	public:
		OpenObserver(Hummingbird* b) : parent(b) {}
		void update(Observable* o, Argument* arg) {
			cout << "Hummingbird " << parent->name << "'s breakfast time" << endl;
		}
	} openObsrv;

	class CloseObserver;
	friend class Hummingbird::CloseObserver;
	class CloseObserver : public Observer {
		Hummingbird* parent;
	public:
		CloseObserver(Hummingbird* b) : parent(b) {}
		void update(Observable* o, Argument* arg) {
			cout << "Hummingbird " << parent->name << "'s bed time!" << endl;
		}
	} closeObsrv;
public:
	Hummingbird(string nm) : name(nm), openObsrv(this), closeObsrv(this) {}
	Observer& openObserver() { return openObsrv; }
	Observer& closeObserver() { return closeObsrv; }
};

int main() {
	Flower f;
	Bee ba("A"), bb("B");
	Hummingbird ha("A"), hb("B");
	f.openNotifier.addObserver(ha.openObserver());
	f.openNotifier.addObserver(hb.openObserver());
	f.openNotifier.addObserver(ba.openObserver());
	f.openNotifier.addObserver(bb.openObserver());
	f.closeNotifier.addObserver(ha.closeObserver());
	f.closeNotifier.addObserver(hb.closeObserver());
	f.closeNotifier.addObserver(ba.closeObserver());
	f.closeNotifier.addObserver(ba.closeObserver());
	// Hummingbird B decides to sleep in
	f.openNotifier.deleteObserver(hb.openObserver());
	// something changes that interests observers
	f.open();
	f.open();	// It's already open, no change
	// Bee A doesn't want to go to bed
	f.closeNotifier.deleteObserver(ba.closeObserver());
	f.close();
	f.close();	// It's already closed, no change
	f.openNotifier.deleteObservers();
	f.open();
	f.close();
}
~~~

## 13 多重派遣

​	`C++`只执行单重派遣。这就是说，如果在多个不知道类型的对象之间操作，`C++`只能在其中一个类型上激发动态绑定机制。

​	程序员手工发现一些类型并且有效地制造自己的动态绑定行为，这种解决办法被称为多重派遣。如果想要发生多重派遣，必须有一个虚函数调用以确定每个未知的类型。因此，如果处理的是不同层次结构的两个类型的交互作用，则每个层次结构都必须有一个虚函数调用。通常，将设立这样一种结构，使得一个成员函数的调用导致多个虚函数调用，并且因此在该过程中确定多个类型：对于每个派遣都需要一个虚函数调用。

​	下面的例子中被调用的虚函数是`complete()`和`eval()`，二者都是同一类型的成员函数（对于多重派遣这并不是必要条件）：

~~~c++
#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>
#include <ctime>
#include <cstdlib>
using namespace std;

class Paper;
class Scissors;
class Rock;

enum Outcome { WIN, LOSE, DRAW };

ostream& operator<<(ostream& os, const Outcome out) {
	switch(out) {
	default:
	case WIN: return os << "win";
	case LOSE: return os << "lose";
	case DRAW: return os << "draw";
	}
}

class Item {
public:
	virtual Outcome compete(const Item*) = 0;
	virtual Outcome eval(const Paper*) const = 0;
	virtual Outcome eval(const Scissors*) const = 0;
	virtual Outcome eval(const Rock*) const = 0;
	virtual ostream& print(ostream& os) const = 0;
	virtual ~Item() {}
	friend ostream& operator<<(ostream& os, const Item* it) {
		return it->print(os);
	}
};

class Paper : public Item {
public:
	Outcome compete(const Item* it) { return it->eval(this); }
	Outcome eval(const Paper*) const { return DRAW; }
	Outcome eval(const Scissors*) const { return WIN; }
	Outcome eval(const Rock*) const { return LOSE; }
	ostream& print(ostream& os) const {
		return os << "Paper ";
	}
};

class Scissors : public Item {
public:
	Outcome compete(const Item* it) { return it->eval(this); }
	Outcome eval(const Paper*) const { return LOSE; }
	Outcome eval(const Scissors*) const { return DRAW; }
	Outcome eval(const Rock*) const { return WIN; }
	ostream& print(ostream& os) const {
		return os << "Scissors ";
	}
};

class Rock : public Item {
public:
	Outcome compete(const Item* it) { return it->eval(this); }
	Outcome eval(const Paper*) const { return WIN; }
	Outcome eval(const Scissors*) const { return LOSE; }
	Outcome eval(const Rock*) const { return DRAW; }
	ostream& print(ostream& os) const {
		return os << "Rock ";
	}
};

struct ItemGen {
	Item* operator()() {
		switch(rand() % 3) {
		default:
		case 0: return new Scissors;
		case 1: return new Paper;
		case 2: return new Rock;
		}
	}
};

struct Compete {
	Outcome operator()(Item* a, Item* b) {
		cout << a << "\t" << b << "\t";
		return a->compete(b);
	}
};

int main() {
	srand(time(0));
	const int sz = 20;
	vector<Item*> v(sz * 2);
	generate(v.begin(), v.end(), ItemGen());
	transform(v.begin(), v.begin() + sz, v.begin() + sz, 
		ostream_iterator<Outcome>(cout, "\n"), Compete());
}
~~~

​	Item是将被多重派遣的那些类型的基类。`Compete::operator()`有两个`Item*`类型的参数，并不知道两者的确切类型，并且调用`virtual Item::compete()`函数开始双重派遣过程。虚拟机制决定了a的类型，因此它激发了在函数`compete()`内部的a的具体类型的产生。在保留该类型的基础之上，函数`compete()`调用`eval()`执行第2次派遣。将其自身作为一个参数传递给函数`eval()`，从而产生一个对重载的`eval()`函数的调用，因此保存了第1次派遣的类型信息。在完成第2次派遣时，两个Item对象的确切类型就知道了。

​	建立多重派遣需要做很多工作，但是请记住这样做的好处是在调用的时候能够以简洁的句法表达方式达到预期的效果 --  而不是编写出笨拙的代码在调用的时候决定一个或多个对象的类型。然而，在编写多重派遣的程序代码之前，确保这种简洁性是非常重要的。

​	注意，利用表查找来进行多重派遣是有效的。在这里使用虚函数来进行查找，用来代替进行杂乱的表查找。如果有较多的派遣（并且有增加和修改的可能），表查找也许是更好的解决问题的方法。

### 13.1 用访问者模式实现多重派遣

​	访问者模式的目标是将类继承层次结构上的操作与这个层次结构本身分开。这是一个相当古怪的动机，因为在面向对象编程中所做的大部分工作是将数据和操作组合在一起来形成对象，并利用多态性根据对象的确切类型自动选择操作的正确变化。

​	利用访问者模式将操作从类的继承层次结构中提取出来置入一个独立的外部层次结构。“主层次结构”包含一个函数`visit()`，该函数接受任何来自操作层次结构的对象。结果得到了两个类继承层次结构而不是一个。此外，可以看到，“主层次结构”变得很脆弱 -- 如果要增加一个新类，也要强制改动第2个层次结构。因此，`GoF`认为主层次结构应该“很少地变化”。

​	用户需要向基类中添加新的成员函数，但是由于某种原因用户不能接触到基类。那么该如何处理这种情况呢？

​	访问者模式建立于前面提到的双重派遣方案之上。访问者模式允许创建一个独立的类层次结构`Visitor`而有效地对主类的接口进行扩展，这个独立的类层次结构将主类上的各种操作“虚化”。主类对象仅接受访问者，然后调用访问者的动态绑定的成员函数。因此，创建一个访问者，并将其传递给主层次结构，便可以获得和虚函数一样的效果。

~~~c++
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cstdlib>
using namespace std;

class Gladiolus;
class Renuculus;
class Chrysanthemum;

class Visitor {
public:
	virtual void visit(Gladiolus* f) = 0;
	virtual void visit(Renuculus* f) = 0;
	virtual void visit(Chrysanthemum* f) = 0;
	virtual ~Visitor() {}
};

class Flower {
public:
	virtual void accept(Visitor&) = 0;
	virtual ~Flower() {}
};

class Gladiolus : public Flower {
public:
	virtual void accept(Visitor& v) {
		v.visit(this);
	}
};

class Renuculus : public Flower {
public:
	virtual void accept(Visitor& v) {
		v.visit(this);
	}
};

class Chrysanthemum : public Flower {
public:
	virtual void accept(Visitor& v) {
		v.visit(this);
	}
};

// Add the ability to produce a string
class StringVal : public Visitor {
	string s;
public:
	operator const string&() { return s; }
	virtual void visit(Gladiolus* f) {
		s = "Gladiolus";
	}
	virtual void visit(Renuculus* f) {
		s = "Renuculus";
	}
	virtual void visit(Chrysanthemum* f) {
		s = "Chrysanthemum";
	}
};

// Add the ability to do "Bee" activities
class Bee : public Visitor {
public:
	virtual void visit(Gladiolus* f) {
		cout << "Bee and Gladiolus" << endl;
	}
	virtual void visit(Renuculus* f) {
		cout << "Bee and Renuculus" << endl;
	}
	virtual void visit(Chrysanthemum* f) {
		cout << "Bee and Chrysanthemum" << endl;
	}
};

struct FlowerGen {
	Flower* operator()() {
		switch(rand() % 3) {
		default:
		case 0: return new Gladiolus;
		case 1: return new Renuculus;
		case 2: return new Chrysanthemum;
		}
	}
};

int main() {
	srand(time(0));
	vector<Flower*> v(10);
	generate(v.begin(), v.end(), FlowerGen());
	vector<Flower*>::iterator it;
	StringVal sval;
	for (it = v.begin(); it != v.end(); it++) {
		(*it)->accept(sval);
		cout << string(sval) << endl;
	}

	Bee bee;
	for (it = v.begin(); it != v.end(); it++) {
		(*it)->accept(bee);
	}
}
~~~

​	`Flower`是主层次结构，`Flower`的各个子类通过函数`accept()`得到一个`Visitor`。`Flower`主层次结构除了函数`accept()`外没有别的操作，因此`Flower`主层次结构的所有功能都包含在`Visitor`层次结构中。注意，`Visitor`类必须要了解`Flower`的所有具体类型，如果添加了一个`Flower`的新类型，整个`Visitor`层次结构必须重新工作。

​	因为其不寻常的动机以及显得愚笨的约束，使得人们极不可能使用访问者模式。

