# 2 -10 设计模式

## 1 模式的概念

​	最初，可以将模式看做解决某一类特定问题的特别巧妙和具有洞察力的方法。它体现出一支开发团队从一个问题的所有角度出发做出全面的分析后，提出的最通用最灵活的对这类问题的解决方案。

​	可以把模式的基本概念看做一般情况下程序设计的基本概念：增加一些抽象层。当人们对事物进行抽象的时候，隔离特定的细节，最直接的动机之一就是为了**使变化的事物和不变的事物分离开**。做到这一点的另一个方法是，一旦发现程序中的某些部分可能被修改，那么就要阻止那些修改在代码中导出传播副作用。如果做到了这一点，代码不仅比较容易阅读和理解，而且也比较容易维护，这样做就会带来一个注定的结果，就是在软件开发的全过程中降低成本。

​	开发一种优雅和可维护的软件设计最困难的部分，常常是发现所谓的**“变化向量”**。这就意味着寻找系统中变化的最重要的事物，换句话说，寻找系统中开发成本最高的地方。一旦找到这个**“变化向量”**，就可以围绕这个焦点来构建系统的设计。

​	因此，设计模式的目标是**封装变化**。

​	**对象组合优于类继承。一个似乎需要继承的设计常常能够戏剧性的使用组合来代替而大大简化，从而使其更灵活。因此，在考虑一个设计时，问问自己：“使用组合是不是更简单？这里真的需要继承吗？它能带来什么好处？”**

## 2 模式的分类

​	`GoF`讨论了23中模式，按照下面三种目的分类：

- **1 创建型(`Creational`)：**用于怎样创建一个对象。通常包括隔离对象创建的细节，这样代码不依赖于对象是什么类型，因此在增加一种新的对象类型时不需要改变代码。例如单例(`Singleton`)模式、工厂(`Factory`)模式和构建器(`Builder`)模式。
- **2 结构型(`Structural`)：**影响对象之间的连接方式，确保系统的变化不需要改变对象间的连接。结构型模式常常由工程项目限制条件来支配。例如代理(`Proxy`)模式和适配器(`Aaapter`)模式。
- **3 行为型(`Behavioral`)：**在程序中处理具有特定操作类型的对象。这些对象封装要执行的操作过程，比如解释一种语言、实践一个请求、遍历一个序列或者实现一种算法。例如命令(`Command`)模式、模板方法(`Template Method`)模式、状态(`State`)模式、策略(`Strategy`)模式、职责链(`Chain of Responsibility`)模式、观察者(`Observer`)模式、多派遣(`Multiple Dispatching`)模式和访问者(`Visitor`)模式。

## 3 单例

​	单例是允许一个类有且仅有一个实例的方法。

~~~c++
#include <iostream>
using namespace std;

class Singleton {
	static Singleton s;
	int i;
	Singleton(int x) : i(x) {}
	Singleton& operator=(const Singleton&);
	Singleton(const Singleton&);
public:
	static Singleton& instance() { return s; }
	int getValue() { return i; }
	void setValue(int x) { i = x; }
};

Singleton Singleton::s(47);

int main() {
	Singleton& s = Singleton::instance();
	cout << s.getValue() << endl;
	Singleton& s2 = Singleton::instance();
	s2.setValue(9);
	cout << s.getValue() << endl;
}
~~~

​	创建一个单例模式的关键是防止客户程序员获得任何控制其对象生存期的权利。为了做到这一点，声明所有的构造函数为私有，并且防止编译器隐式生成任何构造函数。拷贝构造函数和赋值操作符（故意没有实现，因为它们根本不会被调用）被声明为私有，以便防止任何这类复制动作的产生。

​	还必须决定如何去创建这个对象。在这里，它是被静态创建的。也可以等待，直到客户程序员提出要求再根据要求进行创建。这被称作惰性初始化，这种做法，只在创建对象的代价不大，并且并不总是需要它的情况下才有意义。

​	返回引用，而不是返回指针，是一种安全的实现方法。

​	**单例的变体**	

- 将在一个成员函数内部的静态对象的创建与单例类结合在一起：

~~~c++
class Singleton {
	int i;
	Singleton(int x) : i(x) {}
	Singleton& operator=(const Singleton&);
	Singleton(const Singleton&);
public:
	static Singleton& instance() { 
		static Singleton s(47);
		return s; 
	}
	int getValue() { return i; }
	void setValue(int x) { i = x; }
};
~~~

- 如果两个单件彼此依赖，就会产生一个特别有趣的情况：

~~~c++
class Singleton1 {
	Singleton1() {}
public:
	static Singleton1& ref() {
		static Singleton1 single;
		return single;
	}
};

class Singleton2 {
	Singleton1& s1;
	Singleton2(Singleton1& s) : s1(s) {}
public:
	static Singleton2& ref() {
		static Singleton2 single(Singleton1::ref());
		return single;
	}
	Singleton1& f() { return s1; }
};

int main() {
	Singleton1& s1 = Singleton2::ref().f();
}
~~~

​	当调用`Singleton2::ref()`时，它导致其唯一的`Singleton2`对象被创建。在这个对象的创建过程中，`Singleton1::ref()`被调用，这导致其唯一的`Singleton1`对象被创建。因为这种技术不依赖连接或装载的顺序，因此程序员能够很好的控制初始化的全过程，而导致较少的错误。

- 采用将一个对象的**单件属性**从其实现中分离出来的方法：

~~~c++
#include <iostream>
using namespace std;

template<class T> class Singleton {
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
protected:
	Singleton() {}
	virtual ~Singleton() {}
public:
	static T& instance() {
		static T theInstance;
		return theInstance;
	}
};

// A sample class to be made into a singleton
class MyClass : public Singleton<MyClass> {
	int x;
protected:
	friend class Singleton<MyClass>;
	MyClass() { x = 0; }
public:
	void setValue(int n) { x = n; }
	int getValue() const { return x; }
};

int main() {
	MyClass& m = MyClass::instance();
	cout << m.getValue() << endl;
	m.setValue(1);
	cout << m.getValue() << endl;
}
~~~

​	`MyClass`通过下面三个步骤产生一个单例：

1. 声明其构造函数为私有或保护的。
2. 声明类`Singleton<MyClass>`为友元。
3. 从`Singleton<MyClass>`派生出`MyClass`。

​	第三步中的自引用可能令人难以置信。这只是对模板`Singleton`中模板参数的静态依赖。换句话说，`Singleton<MyClass>`的代码之所以能够被编译器实例化，是因为它不依赖于类`MyClass`的大小。只是在后来，当函数`Singleton<MyClass>::instance()`第1次被调用时，才需要类`MyClass`的大小，而此时编译器已经知道类`MyClass`的大小了。

## 4 命令

​	命令模式就是一个函数对象：一个作为对象的函数。通过将函数封装为对象，就能够以参数的形式将其传递给其他函数或者对象，告诉它们在履行请求的过程中执行特定的操作。

​	命令模式的主要特点是允许向一个对象或函数传递一个想要的动作。

~~~c++
#include <iostream>
#include <vector>
using namespace std;

class Command {
public:
	virtual void execute() = 0;
};

class Hello : public Command {
public:
	void execute() { cout << "Hello " << endl; }
};

class World : public Command {
public:
	void execute() { cout << "World! " << endl; }
};

class IAm : public Command {
public:
	void execute() { cout << "I'm the command pattern" << endl; }
};

// An object that holds commands
class Macro {
	vector<Command*> commands;
public:
	void add(Command* c) { commands.push_back(c); }
	void run() {
		vector<Command*>::iterator it = commands.begin();
		while(it != commands.end()) {
			(*it++)->execute();
		}
	}
};

int main() {
	Macro macro;
	macro.add(new Hello);
	macro.add(new World);
	macro.add(new IAm);
	macro.run();
}
~~~

**利用命令模式消除与事件处理的耦合**

~~~c++
#include <iostream>
#include <vector>
#include <string>
#include <ctime>
#include <cstdlib>
using namespace std;

// Framework for running tasks
class Task {
public:
	virtual void operation() = 0;
};

class TaskRunner {
	static vector<Task*> tasks;
	TaskRunner() {}
	TaskRunner& operator=(const TaskRunner&);
	TaskRunner(const TaskRunner&);
	static TaskRunner tr;
public:
	static void add(Task& t) { tasks.push_back(&t); }
	static void run() {
		vector<Task*>::iterator it = tasks.begin();
		while(it != tasks.end()) {
			(*it++)->operation();
		}
	}
};

TaskRunner TaskRunner::tr;
vector<Task*> TaskRunner::tasks;

class EventSimulator {
	clock_t creation;
	clock_t delay;
public:
	EventSimulator() : creation(clock()) {
		delay = CLOCKS_PER_SEC / 4 * (rand() % 20 + 1);
		cout << "delay = " << delay << endl;
	}
	bool fired() {
		return clock() > creation + delay;
	}
};

// Something that can produce asynchronous events
class Button {
	bool pressed;
	string id;
	EventSimulator e;
public:
	Button(string name) : pressed(false), id(name) {}
	void press() { pressed = true; }
	bool isPressed() {
		if (e.fired()) {
			press();
		}
		return pressed;
	}
	friend ostream& operator<<(ostream& os, const Button& b) {
		return os << b.id;
	}
};

// The command object
class CheckButton : public Task {
	Button& button;
	bool handled;
public:
	CheckButton(Button& b) : button(b), handled(false) {}
	void operation() {
		if (button.isPressed() && !handled) {
			cout << button << " pressed" << endl;
			handled = true;
		}
	}
};

// The procedures that perform the main processing. These need to be 
// occasionally interrupted in order to check the state of the buttons 
// or other events
void procedure1() {
	TaskRunner::run();
};

void procedure2() {
	TaskRunner::run();
}

void procedure3() {
	TaskRunner::run();
}

int main() {
	srand(time(0));
	Button b1("Button 1"), b2("Button 2"), b3("Button 3");
	CheckButton cb1(b1), cb2(b2), cb3(b3);
	TaskRunner::add(cb1);
	TaskRunner::add(cb2);
	TaskRunner::add(cb3);
	cout << "Control-C to exit" << endl;
	while(true) {
		procedure1();
		procedure2();
		procedure3();
	}
}
~~~

​	在这里，`EventSimulator`创建一个随机延迟时间，所以当周期性地调用函数fired()时，在某个随机时间段，其返回结果从true到false变化。`EventSimulator`对象在类Button中使用，模拟在某个不可预知的时间段用户事件发生的动作。`CheckButton`是Task的实现，在程序中通过所有正常代码对其进行周期性的检查。

## 5 消除对象耦合

​	代理模式(Proxy)和状态模式(State)都提供一个代理类(Surrogate)。代码与代理类打交道，而做实际工作的类隐藏在代理类背后。这两种模式很相似，从结构上看，可以认为代理模式只是状态模式的一个特例。但这两个模式的内涵是不一样的。

​	基本思想是：代理类(Surrogate)派生自一个基类，由平行地派生自同一个基类的一个或多个类提供实际的实现。当一个代理对象被创建的时候，一个实现对象就分配给了它，代理对象就将函数调用发给实现对象。

​	代理模式和状态模式的区别：代理模式只有一个实现类，而状态模式有多个实现。`GoF`认为这两种设计模式的应用也不同：代理模式控制对其实现类的访问，而状态模式动态地改变其实现类。

### 5.1 代理模式：作为其他对象的前端

~~~c++
#include <iostream>
using namespace std;

class ProxyBase {
public:
	virtual void f() = 0;
	virtual void g() = 0;
	virtual void h() = 0;
	virtual ~ProxyBase() {}
};

class Implementation : public ProxyBase {
public:
	void f() { cout << "Implementation.f()" << endl; }
	void g() { cout << "Implementation.g()" << endl; }
	void h() { cout << "Implementation.h()" << endl; }
};

class Proxy : public ProxyBase {
	ProxyBase* implementation;
public:
	Proxy() { implementation = new Implementation(); }
	~Proxy() { delete implementation; }
	// Forward calls to the implementation
	void f() { implementation->f(); }
	void g() { implementation->g(); }
	void h() { implementation->h(); }
};

int main() {
	Proxy p;
	p.f();
	p.g();
	p.h();
}
~~~

​	某些情况下，Implementation并不需要与类Proxy具有相同的接口 -- Proxy类可以任意关联Implementation类并且将函数调用提交给它，这就符合了代理的基本思想。然而，使用共同的接口可以将代理的替代物插入到客户代码中 -- 编写客户代码只用来与原对象进行通信，不需要对其进行修改以接受代理。

​	代理模式的一般用途：

1. **远程代理(Remote Proxy)**。为不同地址空间的对象提供代理。通过某些远程对象技术实现。
2. **虚拟代理(Virtual Proxy)**。根据需要提供一种“惰性初始化”方式来创建高代价的对象。
3. **保护代理(Protection Proxy)**。当不愿意客户程序员拥有被代理对象的全部访问权限时，使用保护代理。
4. **巧妙引用(Smart reference)**。当访问被代理的对象时，增加额外的活动。引用计数就是一个例子。

### 5.2 状态模式：改变对象的行为

​	状态模式产生一个可以改变其类的对象，当发现在大多数或者所有函数中都存在有条件的代码时，这种模式很有用。在前端对象生存期期间，状态模式从一个实现对象到另一个实现对象进行切换，以实现对于相同的函数调用产生不同的行为。

~~~c++
#include <iostream>
#include <string>
using namespace std;

class Creature {
	class State {
	public: 
		virtual string response() = 0;
	};
	class Frog : public State {
	public:
		string response() { return "Ribbet!"; }
	};
	class Prince : public State {
	public:
		string response() { return "Darling!"; }
	};
	State* state;
public:
	Creature() : state(new Frog()) {}
	void greet() {
		cout << state->response() << endl;
	}
	void kiss() {
		delete state;
		state = new Prince();
	}
};

int main() {
	Creature creature;
	creature.greet();
	creature.kiss();
	creature.greet();
}
~~~

​	对状态类的改变会自动地在所有代码中进行传播，而不需要编辑这些类来完成改变。

## 6 适配器模式

​	适配器模式接受一种类型并且提供一个对其他类型的接口。当给定一个库或者具有某一接口的一段代码，同时还给定另外一个库或者与前面那段代码的基本思想相同的一段代码而只是表达方式不一致时，适配器模式将十分有用。通过调整彼此的表达方式以适配彼此，将会迅速产生解决办法。

~~~c++
#ifndef FIBONACCIGENERATOR_H
#define FIBONACCIGENERATOR_H

class FibonacciGenerator {
	int n;
	int val[2];
public:
	FibonacciGenerator() : n(0) { val[0] = val[1] = 0; }
	int operator()() {
		int result = n > 2 ? val[0] + val[1] : n > 0 ? 1 : 0;
		++n;
		val[0] = val[1];
		val[1] = result;
		return result;
	}
	int count() { return n; }
};
#endif
~~~

~~~c++
// Adapting an interface to something you already have
#include <iostream>
#include <numeric>
#include "FibonacciGenerator.h"
using namespace std;

class FibonacciAdapter {
	FibonacciGenerator f;
	int length;
public:
	FibonacciAdapter(int size) : length(size) {}
	class iterator;
	friend class iterator;
	class iterator : public std::iterator<std::input_iterator_tag, FibonacciAdapter, ptrdiff_t> {
		FibonacciAdapter& ap;
	public:
		typedef int value_type;
		iterator(FibonacciAdapter& a) : ap(a) {}
		bool operator==(const iterator&) const {
			return ap.f.count() == ap.length;
		}
		bool operator!=(const iterator& x) const {
			return !(*this == x);
		}
		int operator*() const { return ap.f(); }
		iterator& operator++() { return *this; }
		iterator& operator++(int) { return *this; } 
	};
	iterator begin() { return iterator(*this); }
	iterator end() { return iterator(*this); }
};

int main() {
	const int SZ = 20;
	FibonacciAdapter a1(SZ);
	cout << "accumulate: " << accumulate(a1.begin(), a1.end(), 0) << endl;
	FibonacciAdapter a2(SZ), a3(SZ);
	cout << "inner product: " << inner_product(a2.begin(), a2.end(), a3.begin(), 0) << endl;
	FibonacciAdapter a4(SZ);
	int r1[SZ] = {0};
	int* end = partial_sum(a4.begin(), a4.end(), r1);
	FibonacciAdapter a5(SZ);
	int r2[SZ] = {0};
	end = adjacent_difference(a5.begin(), a5.end(), r2);
}
~~~

## 7 模板方法模式

​	模板方法模式的一个重要特征是它的定义在基类中(有时作为一个私有成员函数)并且不能改动 -- 模板方法模式就是坚持相同的代码。它调用其他基类函数(就是那些被覆盖的函数)以便完成其工作，但是客户程序员不必直接调用这些函数。

~~~c++
#include <iostream>
using namespace std;

class ApplicationFramework {
protected:
	virtual void customize1() = 0;
	virtual void customize2() = 0;
public:
	void templateMethod() {
		for (int i = 0; i < 5; ++i){
			customize1();
			customize2();
		}
	}
};

// Create a new Application
class MyApp : public ApplicationFramework {
protected:
	virtual void customize1() { cout << "Hello "; }
	virtual void customize2() { cout << "World!" << endl; }
};

int main() {
	MyApp app;
	app.templateMethod();
}
~~~

