# 2 - 11 并发

​	本文使用`ZThread`库，以传达线程处理的基本思想。

## 1、`ZThread`库在Windows平台上的编译方法

- 从官网上下载`ZThread`库的最新版本；
- 使用`VS2010`新建一个空白的静态库项目；
- 将`ZThread`库中的`include`目录设为包含目录；
- 将`ZThread`库中的`src`目录中的文件引入项目中；
- 使用`VS2010`进行编译；

**编译动态库的方法类似。**

## 2 `ZThread`库的使用示例

~~~c++
class LiftOff : public ZThread::Runnable {
	int countDown;
	int id;

public:
	LiftOff(int count, int ident = 0)
		: countDown(count), id(ident){}

	~LiftOff(){
		std::cout << id << " completed" << std::endl;
	}

	void run() {
		while (countDown--) {
			std::cout << id << ":" << countDown << std::endl;
		}
		std::cout << "LiftOff!" << std::endl;
	}
};
~~~

### 2.1 普通用法

~~~c++
#include <iostream>
#include "LiftOff.h"
#include "zthread/Thread.h"
using namespace ZThread;
using namespace std;

int main() {
	const int SZ = 5;
	try {
		for (int i = 0; i < SZ; ++i){
			Thread t(new LiftOff(10, i));
		}
		cout << "Waiting for LiftOff" << endl;
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
	return 0;
}
~~~

### 2.2 使用执行器简化工作

**`ThreadedExecutor:`**

~~~c++
#include <iostream>
#include "zthread/ThreadedExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		ThreadedExecutor executor;
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	`ThreadedExecutor`为需要运行的每个任务都创建了一个线程，用一个不同类型的`Executor`对象来代替`ThreadedExecutor`对象，就可以容易的改变任务的执行方式。使用`PoolExecutor`对象来替换`ThreadedExecutor`对象，它使用一个有限的线程集以并行的方式执行提交的任务。

**`PoolExecutor:`**

~~~c++
#include <iostream>
#include "zthread/PoolExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		PoolExecutor executor(5);
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	使用`PoolExecutor`，可以预先将开销很大的线程分配工作一次做完，在可能的时候重用这些线程。这样做会节省时间，因为不会因不断地为了每个任务都创建一个线程而付出那些开销。并且在一个事件驱动的系统中，对于一些需要由线程来处理的事件，可以以很快的方式产生。而这些快速产生的线程可以仅从线程池中取出线程的方式来提供。

**`ConcurrentExecutor:`**

~~~c++
#include <iostream>
#include "zthread/ConcurrentExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		ConcurrentExecutor executor;
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	`ConcurrentExecutor`类就像是一个`PoolExecutor`类，该类有大小固定的一个线程。对于需要在另一个线程中不断运行的任务(长期处于活动状态的任务)来说，或者需要在线程中运行的短任务来说，这个类是很有用的。

​	如果有多个任务被提交至一个`ConcurrentExecutor`，每个任务都会在下一个任务开始之前执行完成，所有的任务都使用同一个线程。`ConcurrentExecutor`串行化执行提交给它的任务。

**`SynchronousExecutor:`**

~~~c++
#include <iostream>
#include "zthread/SynchronousExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		SynchronousExecutor executor;
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		} 
	} catch (Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	类似`ConcurrentExecutor`，`SynchronousExecuror`用于需要同一时刻只执行一个任务的时候，串行代替了并发。`SynchronousExecuror`自己不创建或管理线程。它使用提交任务的线程，因此只会作为同步的焦点来行动。如果有n个线程向`SynchronousExecuror`提交了任务，永远不会同一时刻运行两个任务。另外，每个任务完成以后，队列里的下一个任务才会开始执行。

### 2.3 让步(yield)

​	可以调用`yield()`函数给线程调度机制一个暗示，现在已经做完了该做的工作，可以让其他线程使用CPU了。这个暗示仅仅是一个暗示，不能保证所实现的系统会监听到它。一般情况下，`yield()`只在极少的情形下有用处，不能依赖它来对应用程序做出任何严谨的调整。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

class YieldingTask : public Runnable {
	int countDown;
	int id;

public:
	YieldingTask(int ident = 0) : countDown(5), id(ident) {}
	~YieldingTask() { cout << id << " completed" << endl; }
	
	friend ostream& operator<<(ostream& os, const YieldingTask& yt) {
		return os << "#" << yt.id << ": " << yt.countDown;
	}

	void run() {
		while(true) {
			cout << *this << endl;
			if (--countDown == 0) {
				return;
			}
			Thread::yield();
		}
	}
};

int main() {
	try {
		ThreadedExecutor executor;
		for (int i = 0; i < 5; ++i){
			executor.execute(new YieldingTask(i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

### 2.4 休眠(sleep)

​	调用函数`sleep()`，使线程根据给定的毫秒数停止执行一段时间，也可以控制线程行为。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

class SleepingTask : public Runnable {
	int countDown;
	int id;

public:
	SleepingTask(int ident = 0) : countDown(5), id(ident) {}
	~SleepingTask() { cout << id << " completed" << endl; }

	friend ostream& operator<<(ostream& os, const SleepingTask& yt) {
		return os << "#" << yt.id << ": " << yt.countDown;
	}

	void run() {
		while(true) {
			try {
				cout << *this << endl;
				if (--countDown == 0) {
					return;
				}
				Thread::sleep(100);
			} catch (Interrupted_Exception& e) {
				cerr << e.what() << endl;
			}
		}
	}
};

int main() {
	try {
		ThreadedExecutor executor;
		for (int i = 0; i < 5; ++i){
			executor.execute(new SleepingTask(i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	**`Thread::sleep()`可以跑出一个`Interrupted_Exception`异常，这个异常在`run()`中被捕获，是因为异常不会跨越线程传播倒退回`main()`中。因此，必须对可能在任务中出现的任何局部性异常进行处理。**

​	`sleep()`也不是一个控制线程执行顺序的办法。它仅会让线程的执行停止片刻。只能保证线程至少休眠给定的时间，但线程恢复执行前可能需要更多的时间，因为在休眠间歇期过后，线程调度器还需要时间来恢复它。

​	**如果必须要控制线程的执行顺序，最好的办法是使用同步控制，或者在某些情况下，根本不使用线程，而是自己编写以特定的顺序相互控制的协作子例程。**

### 2.5 优先权

​	线程优先权向线程调度器传达一个线程的重要性。虽然CPU以一个不确定的顺序运行一个线程集，但是在这些等待的线程中，线程调度器将倾向于先运行有最高优先权的等待线程，有较低优先权的线程运行较少。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
using namespace ZThread;
using namespace std;

const double pi = 3.14159265358979323846;
const double e = 2.7182818284590452354;

class SimplePriorities : public Runnable {
	int countDown;
	volatile double d;
	int id;
public:
	SimplePriorities(int ident = 0) : countDown(5), id(ident) {}
	~SimplePriorities() { cout << id << " completed" << endl; }

	friend ostream& operator<<(ostream& os, const SimplePriorities& sp) {
		return os << "#" << sp.id << " priority: " << Thread().getPriority()
			<< " count: " << sp.countDown;
	}

	void run() {
		while (true) {
			for (int i = 1; i < 100000; ++i)
			{
				d = d + (pi + e) / double(i);
			}
			cout << *this << endl;
			if (--countDown) {
				return;
			}
		}
	}
};

int main() {
	try {
		Thread high(new SimplePriorities);
		high.setPriority(High);
		for (int i = 0; i < 5; ++i) {
			Thread low(new SimplePriorities(i));
			low.setPriority(Low);
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	将优先权映射到操作系统的做法是有问题的。只有将优先权级别划分成非常大的粒度才是一个接近实用的方法。

## 3 共享有限的资源

​	使用多线程进行处理时，可能有两个或更多个线程试图在同一时刻使用同一个资源。这就可能引起两种不同的问题：必须的资源可能不存在；两个或更多的线程在其试图同时访问同一个资源时可能会发生冲突。

### 3.1 保证对象的存在

​	`ZThread`中的`Runnable`任务被`ZThread`库机制自动地进行了引用计数。任务一直维持到该任务的引用计数归零，此时才能删除该任务。即必须总是动态的删除任务，所以`Runnable`不能在栈上创建，必须总是用`new`来创建。

​	为了保证在这些任务之间任何被共享的对象要长期存在，就可以把对象放置在堆上。并且确保直到没有其他对象使用它时才能被销毁。`ZThread`库包含一个名叫`CountedPtr`的模板，它自动执行引用计数并在引用计数归零时用`delete`删除一个对象。

​	每当有对象被多于一个任务使用时，几乎总是需要使用`CountedPtr`模板来管理那些对象，以防由对象生存期争端而产生的问题。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/CountedPtr.h"
using namespace ZThread;
using namespace std;

class Count {
	enum { SZ = 100 };
	int n[SZ];
public:
	void increment() {
		for (int i = 0; i < SZ; ++i) {
			n[i]++;
		}
	}
};

class Incrementer : public Runnable {
	CountedPtr<Count> count;
public:
	Incrementer(const CountedPtr<Count>& c) : count(c) {}
	void run() {
		for (int n = 100; n > 0; n--) {
			Thread::sleep(250);
			count->increment();
		}
	}
};

int main() {
	CountedPtr<Count> count(new Count);
	try {
		Thread t0(new Incrementer(count));
		Thread t1(new Incrementer(count));
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

#### 3.2 不恰当的访问资源

​	竞争条件，即两个或更多的任务竞争着响应同一个条件，因此发生冲突，或者没有发生冲突却产生不一致的结果。必须仔细考虑以防所有可能会使并发系统崩溃的情形发生。例如，一个任务不能依赖于其他任务，因为不能保证任务停止的顺序。这里使用一个例子，由共享公共资源(`Cancelable Generator`)的任务监视着该资源，以便根据标志来结束监视，使任务依赖于非任务对象，消除了潜在的竞争条件。

**`EvenChecker.h`:**

~~~c++
#include <iostream>
#include "zthread/CountedPtr.h"
#include "zthread/Thread.h"
#include "zthread/Cancelable.h"
#include "zthread/ThreadedExecutor.h"

class Generator : public ZThread::Cancelable {
	bool canceled;
public:
	Generator() : canceled(false) {}
	virtual int nextValue() = 0;
	void cancel() { canceled = true; }
	bool isCanceled() { return canceled; }
};

class EvenChecker : public ZThread::Runnable {
	ZThread::CountedPtr<Generator> generator;
	int id;
public:
	EvenChecker(ZThread::CountedPtr<Generator>& g, int ident)
		: generator(g), id(ident) {}
	~EvenChecker() {
		std::cout << "~EvenChecker " << id << std::endl;
	}
	void run() {
		while(!generator->isCanceled()) {
			int val = generator->nextValue();
			if(val % 2 != 0) {
				std::cout << val << " not even!" << std::endl;
				generator->cancel();
			}
		}
	}

	template<typename GenType> static void test(int n = 10) {
		std::cout << "Press Control-C to exit" << std::endl;
		try {
			ZThread::ThreadedExecutor executor;
			ZThread::CountedPtr<Generator> gp(new GenType);
			for(int i = 0; i < n; ++i) {
				executor.execute(new EvenChecker(gp, i));
			}
		} catch(ZThread::Synchronization_Exception& e) {
			std::cerr << e.what() << std::endl;
		}
	}
};
~~~

**`EvenGenerator.cpp:`**

~~~c++
#include <iostream>
#include "EvenChecker.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

class EvenGenerator : public Generator {
	unsigned int currentEvenValue;
public:
	EvenGenerator() { currentEvenValue = 0; }
	~EvenGenerator() { cout << "~EvenGenerator" << endl; }
	int nextValue() {
		++currentEvenValue;
		++currentEvenValue;
		return currentEvenValue;
	}
};

int main() {
	EvenChecker::test<EvenGenerator>();
}
~~~

​	`Generator`类引入了抽象类`Cancelable`，它是`ZThread`库的一部分。`Cancelable`的目的是提供一个一致的接口，以便通过`cancel()`函数来改变对象的状态，用`isCanceled()`函数来检查对象是否已被取消。

#### 3.3 访问控制

​	对于多线程处理的工作，需要一些方法来防止两个线程同时访问一个资源，至少要防止两个线程在临界期内访问同一资源。通过互斥`Mutex`可以解决这个问题。

~~~c++
#include <iostream>
#include "EvenChecker.h"
#include "zthread/ThreadedExecutor.h"
#include "zthread/Mutex.h"
using namespace ZThread;
using namespace std;

class MutexEvenGenerator : public Generator {
	unsigned int currentEvenValue;
	Mutex lock;
public:
	MutexEvenGenerator() { currentEvenValue = 0; }
	~MutexEvenGenerator() { cout << "~MutexEvenGenerator" << endl; }
	int nextValue() {
		lock.acquire();
		++currentEvenValue;
		Thread::yield();
		++currentEvenValue;
		int rval = currentEvenValue;
		lock.release();
		return rval;
	}
};

int main() {
	EvenChecker::test<MutexEvenGenerator>();
}
~~~

​	这里增加了一个叫做`lock`的`Mutex`型变量，并且在`nextValue()`中使用了`acquire()`和`release()`来创建临界区。以这种方法，在同一时刻只有一个线程能够访问被互斥锁所保护的代码。

#### 3.4 使用保护简化编码

​	`ZThread`库以`Guard`模板的方式解决了发生异常或者返回路径过多时，使用互斥锁会很复杂的问题。`Guard`模板创建对象，当这些对象被创建时用`acquire()`函数获得一个`Lockable`对象；当这些`Guard`对象被销毁时，用`release()`函数释放该锁。

~~~c++
#include <iostream>
#include "EvenChecker.h"
#include "zthread/ThreadedExecutor.h"
#include "zthread/Mutex.h"
#include "zthread/Guard.h"
using namespace ZThread;
using namespace std;

class GuardedEvenGenerator : public Generator {
	unsigned int currentEvenValue;
	Mutex lock;
public:
	GuardedEvenGenerator() { currentEvenValue = 0; }
	~GuardedEvenGenerator() { cout << "~GuardedEvenGenerator" << endl; }
	int nextValue() {
		Guard<Mutex> g(lock);
		++currentEvenValue;
		Thread::yield();
		++currentEvenValue;
		return currentEvenValue;
	}
};

int main() {
	EvenChecker::test<GuardedEvenGenerator>();
}
~~~

​	`Guard`还可以被安全地用于操纵其他保护(`Gurad`)。下面程序中的第2个`Guard`可以用于临时解锁一个保护：

~~~c++
class TemporaryUnlocking {
    Mutex lock;
 public:
 	void f() {
        Guard<Mutex> g(lock);
        // lock is acquired
        {
            Guard<Mutex, UnlockedScope> h(g);
            // lock is released
            // ...
            // lock is acquired
        }
        // ...
        // lock is released
    }   
}
~~~

​	`Guard`也可以尝试在一个确定的时间内获得某个锁，然后放弃。下面程序中，如果在500豪秒内不能获得锁，就抛出一个`Timeout_Exception`异常：

~~~c++
class TimedLocking {
    Mutex lock;
public:
    void f() {
        Guard<Mutex, TimedLockedScope<500> > g(lock);
        // ...
    }
}
~~~

​	`ZThread`库还提供了一个`GuardedClass`模板来自动地为整个类创建同步封装器。这意味着该类中的每个成员函数都将自动被保护。

~~~c++
#include "zthread/GuardedClass.h"
using namespace ZThread;

class MyClass {
public:
    void f1() {}
    void f2() {}
};

int main() {
  MyClass a;
  a.f1();	// not synchronizied
  a.f2();	// not synchronizied
  GuardedClass<MyClass> b(new MyClass);
  b->f1();	
  b->f2();
}
~~~

​	对象a是非同步的，所有`f1()`和`f2()`能被任意个线程在任何时刻调用。对象b被`GuardedClass`封装器保护了起来，所以每个成员函数都被自动同步，在任意时刻每个对象仅由一个函数能被调用。

​	**封装器在类一级的粒度上加锁，可能会影响到它的性能。如果一个类包含某些互不相关的函数，也许用两种不同的锁在内部同步这些函数会更好一些。然而如果这样做了，则意味着该类也许包含非强相关的数据组。应该考虑把这个类分解成两个类。**

​	**用一个互斥锁包含一个类的所有成员函数并不能自动保证那个类是线程安全的。必须小心考虑所有的线程处理问题，以便保证线程的安全性。**

#### 3.5 线程本地存储

​	消除任务在共享资源上发生冲突问题的第2种解决办法是消除共享变量，对使用同一个对象的各个不同线程，可以为同一变量创建不同的存储单元。`ZThread`库的`ThreadLocal`模板自动创建和管理线程的本地存储。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/Mutex.h"
#include "zthread/Guard.h"
#include "zthread/ThreadedExecutor.h"
#include "zthread/Cancelable.h"
#include "zthread/ThreadLocal.h"
#include "zthread/CountedPtr.h"
using namespace ZThread;
using namespace std;

class ThreadLocalVariables : public Cancelable {
	ThreadLocal<int> value;
	bool canceled;
	Mutex lock;
public:
	ThreadLocalVariables() : canceled(false) {
		value.set(0);
	}
	void increment() { value.set(value.get() + 1); }
	int get() { return value.get(); }
	void cancel() {
		Guard<Mutex> g(lock);
		canceled = true;
	}
	bool isCanceled() {
		Guard<Mutex> g(lock);
		return canceled;
	}
};

class Accessor : public Runnable {
	int id;
	CountedPtr<ThreadLocalVariables> tlv;
public:
	Accessor(CountedPtr<ThreadLocalVariables>& tl, int ident) 
		: id(ident), tlv(tl) {}
	void run() {
		while (!tlv->isCanceled()) {
			tlv->increment();
			cout << *this << endl;
		}
	}
	friend ostream& operator<<(ostream& os, Accessor& a) {
		return os << "#" << a.id << ": " << a.tlv->get();
	}
};

int main() {
	cout << "Press <Enter> to quit" << endl;
	try {
		CountedPtr<ThreadLocalVariables> tlv(new ThreadLocalVariables);
		const int SZ = 5;
		ThreadedExecutor executor;
		for (int i = 0; i < SZ; ++i) {
			executor.execute(new Accessor(tlv, i));
		}
		cin.get();
		tlv->cancel();
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	当通过实例化`ThreadLocal`模板来创建对象时，只能用`get()`和`set()`成员函数访问该对象的内容。`get()`函数返回一份与那个线程相关联的对象的拷贝，而`set()`则将其参数插入到与那个线程相关的对象中存储，并返回存储单元中原来所保存的对象。

## 4 终止任务

### 4.1 终止任务示例

​	这个程序说明了在结束多线程处理程序的执行时需要多么谨慎。

~~~c++
#include <vector>
#include <cstdlib>
#include <ctime>
#include "Display.h"
#include "zthread/Thread.h"
#include "zthread/FastMutex.h"
#include "zthread/Guard.h"
#include "zthread/ThreadedExecutor.h"
#include "zthread/CountedPtr.h"
using namespace ZThread;
using namespace std;

class Count : public Cancelable {
	FastMutex lock;
	int count;
	bool paused, canceled;
public:
	Count() : count(0), paused(false), canceled(false) {}
	int increment() {
		// Comment the following line to see counting fail
		Guard<FastMutex> g(lock);
		int temp = count;
		if (rand() % 2 == 0) { // yield half the time
			Thread::yield();
		}
		return (count = ++temp);
	}
	int value() {
		Guard<FastMutex> g(lock);
		return count;
	}
	void cancel() {
		Guard<FastMutex> g(lock);
		canceled = true;
	}
	bool isCanceled() {
		Guard<FastMutex> g(lock);
		return canceled;
	}
	void pause() {
		Guard<FastMutex> g(lock);
		paused = true;
	}
	bool isPaused() {
		Guard<FastMutex> g(lock);
		return paused;
	}
};

class Entrance : public Runnable {
	CountedPtr<Count> count;
	CountedPtr<Display> display;
	int number;
	int id;
	bool waitingForCancel;
public:
	Entrance(CountedPtr<Count>& cnt, CountedPtr<Display>& disp, int idn) 
		: count(cnt), display(disp), number(0), id(idn), waitingForCancel(false) {}
	void run() {
		while (!count->isPaused()) {
			++number;
			{
				ostringstream os;
				os << *this << " Total: " << count->increment() << endl;
				display->output(os);
			}
			Thread::sleep(100);
		}
		waitingForCancel = true;
		while (!count->isCanceled()) {
			Thread::sleep(100);
		}
		ostringstream os;
		os << "Terminating " << *this << endl;
		display->output(os);
	}
	int getValue() {
		while (count->isPaused() && !waitingForCancel) {
			Thread::sleep(100);
		}
		return number;
	}
	friend ostream& operator<<(ostream& os,const Entrance& e) {
		return os << "Entrance " << e.id << ": " << e.number;
	}
};

int main() {
	srand(time(0));
	cout << "Press <Enter> to quit" << endl;
	CountedPtr<Count> count(new Count);
	vector<Entrance*> v;
	CountedPtr<Display> display(new Display);
	const int SZ = 5;
	try {
		ThreadedExecutor executor;
		for (int i = 0; i < SZ; ++i) {
			Entrance* task = new Entrance(count, display, i);
			executor.execute(task);
			v.push_back(task);
		}
		cin.get();
		count->pause();	// Causes tasks to stop counting
		int sum = 0;
		vector<Entrance*>::iterator it = v.begin();
		while (it != v.end()) {
			sum += (*it)->getValue();
			++it;
		}
		ostringstream os;
		os << "Total: " << count->value() << endl 
			<< "Sum of Entrances: " << sum << endl;
		display->output(os);
		count->cancel();
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	`Count`是一个主计数器类，能够被所有的`Entrance`对象共享。这里还使用了一个`FastMutex`模板实例，`FastMutex`使用本地操作系统的互斥锁。

​	`Entrance`对象间所发生的所有通信都要通过一个`Count`对象。当用户按下`Enter`键时，`main()`函数用`pause()`发送消息给`count`。由于每个`Entrance::run()`都在监视着`count`对象是否暂停下来，这将引发每个`Entrance`对象迁移到`waitingForCancel`等待状态，在这种状态下它将不再计数，但仍然处于活动状态。这是必要的，因为`main()`必须能安全迭代在`vector<Entrance*>`中的每个对象。注意，因为在一个`Entrance`完成计数并迁移到`waitingForCancel`等待状态之前，发生迭代的可能性很小，可以忽略，所以函数`getValue()`循环调用`sleep()`直到对象迁移到`waitingForCancel`等待状态。(这种形式被称为忙等待，是不受欢迎的。可以使用`wait()`函数进行解决。)一旦`main()`函数完成了对`vector<Entrance*>`的一次遍历迭代，`cancel()`消息就会被传至`count`对象。所有`Entrance`对象都会监视这个状态变化。在这点上，它们打印一条终止信息并从`run()`中退出，这导致每个任务都会被线程处理机制销毁掉。

​	一般情况下一个简单的操作，比如返回一个int变量就是一个原子操作，这意味着获取它在一个微处理器指令中完成而不会被中断。多线程处理机制不能在一个微处理器指令中间停止一个线程，即不能中断一个原子操作，因此原子操作不需要被保护。但C++标准并不能保证任何这类操作的原子性。

### 4.2 终止一个被阻塞的任务

​	一个线程可以处于以下4种状态之一：

- **新建状态(New)**：一个线程只是在被创建的瞬间暂时地保持这个状态。它分配任何必需的系统资源并完成初始化。在这一点上它有资格获得CPU时间。线程调度器随后将该线程转换到可运行或阻塞状态；

- **可运行状态(Runnable)**：这个状态意味着当时间分片机制为该线程分配可利用的CPU周期时，线程就可以运行。因此，在任何时刻，某个时刻线程可能运行也可能不运行，但是如果线程调度器安排它，则没什么事情会阻止其运行；这时，它既不处于死亡状态，也不处于阻塞状态；

- **阻塞状态(Blocked)**：线程可以运行了，但有某种事件阻止了它的运行。当一个线程处于阻塞状态时，线程调度器会忽略该线程并且不分配给它任何CPU时间。直到线程重新进入可运行状态之前，它不执行任何操作；

- **死亡状态(Dead)**：一个处于死亡状态的线程，不能再被调度也不能获得任何CPU时间。它的任务已经完成，不再是可运行的。

  当一个线程不能继续运行时它就处于阻塞状态。一个线程变为阻塞状态的原因如下：

- 调用sleep(milliseconds)使线程进入休眠状态，在这种情况下该线程在指定时间内不会运行。

- 已经使用wait()挂起了该线程的运行。在得到signal()或broadcast()消息之前，它不会再一次变为可运行状态。

- 线程正在等待某个I/O操作完成。

- 线程正在尝试进入一段被一个互斥锁保护的代码块，而那个互斥锁已经被其他线程获得。

**有时需要在某个线程处于阻塞状态时终止它。线程在执行到代码中的某一点上能自己检查状态值并决定结束运行，如果不能等待线程到达代码中的这一点，那么就必须强迫线程脱离阻塞状态。**

### 4.3 中断

​	在`ZThread`库中，异常被用于从一个任务的`run()`函数的中间跳出。为了在以此方式结束一个任务时能返回到一个已知的正确状态，要谨慎地考虑代码的执行路径，在`catch`子句中正确销毁与之相关的对象并清理有关的资源。

​	为了终止一个阻塞的线程，`ZThread`库提供了`Thread::interrupt()`函数。这个函数用来为那类线程设置中断状态。一个使用了中断状态设置的线程，如果已经被阻塞或尝试进行阻塞操作时将会抛出一个`Interrupted_Exception`异常。该异常被抛出或者假如任务调用了`Thread::interrupted()`时，中断状态将重新设置。`Thread::interrupted()`提供了不用抛出异常而离开run()函数中循环的第2条途径。

​	**interrupt()函数的使用：**

~~~c++
#include <iostream>
#include "zthread/Thread.h"
using namespace ZThread;
using namespace std;

class Blocked : public Runnable {
public:
	void run() {
		try {
			Thread::sleep(1000);
			cout << "Waiting for get() in run():";
			cin.get();
		} catch(Interrupted_Exception&) {
			cout << "Caught Interrupted_Exception" << endl;
		}
	}
};

int main(int argc, char* argv[]) {
	try {
		Thread t(new Blocked);
		if (argc > 1)
		{
			Thread::sleep(1100);
		}
		t.interrupt();
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	在这个示例中，如果不给程序传递命令行参数，就会跳过main()中的sleep()。在这里，在任务休眠时发生了对函数interrupt()的调用，这将导致Interrupted_Exception异常被抛出。如果给程序一个命令行参数，就会发现如果一个任务被阻塞在I/O操作上，它不能被中断。也就是说，除了I/O操作，一个任务可以从任何阻塞操作中中断出来。

​	**如果正在创建一个执行IO操作的线程，这意味着I/O操作有使多线程处理程序死锁的潜在可能性。**

#### 4.3.1 中断一个互斥锁阻塞

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/Mutex.h"
#include "zthread/Guard.h"
using namespace ZThread;
using namespace std;

class BlockedMutex {
	Mutex lock;
public:
	BlockedMutex() { lock.acquire(); }
	void f() {
		Guard<Mutex> g(lock);
		// This will never be available
	}
};

class Blocked2 : public Runnable {
	BlockedMutex blocked;
public:
	void run() {
		try {
			cout << "Waiting for f() in BlockedMutex" << endl;
			blocked.f();
		} catch(Interrupted_Exception& e) {
			cerr << e.what() << endl;
		}
	}
};

int main() {
	try {
		Thread t(new Blocked2);
		t.interrupt();
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	`BlockedMutex`类的构造函数中获得对象自己的互斥锁`Mutex`并且绝不释放它。由于这个原因，如果试图调用`f()`，总会被阻塞，因为该互斥锁`Mutex`不能被获得。在`Blocked2`中，`run()`函数将因此停止在对`blocked.f()`的调用上。当运行程序时就会看到，和IO流的调用不同，`interrupt()`能够跳出已被一个互斥锁阻塞的调用。

#### 4.3.2 中断检查

​	当在一个线程上调用interrupt()时，中断仅发生在任务进入一个阻塞操作的那一刻，或者已经在一个阻塞操作之内。如果只能通过在一个被阻塞的调用上抛出异常来退出，也许始终不能离开run()循环。例如调用interrupt()来停止一个任务，但在run()循环中没有发生任何阻塞调用，该任务就需要另外的机会来退出。

​	中断状态提供了这样的机会，它通过调用interrupt()进行设置，调用interrupted()来检查中断状态，这不仅能告知interrupt()是否已经被调用，它也会清除中断状态。清除中断状态可以确保整个架构不会两次通知正被中断的任务。它会用一个Interrupted_Exception异常或者一个成功的Thread::interrupted()测试来通知使用者。如果想再次检查是否被中断了，在调用Thread::interrupted()时可以将测试结果存储起来。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
using namespace ZThread;
using namespace std;

const double PI = 3.14159265758979323846;
const double E = 2.7182818284590452354;

class NeedsCleanup {
	int id;
public:
	NeedsCleanup(int ident) : id(ident) {
		cout << "NeedsCleanup " << id << endl;
	}
	~NeedsCleanup() {
		cout << "~NeedsCleanup " << id << endl;
	}
};

class Blocked3 : public Runnable {
	volatile double d;
public:
	Blocked3() : d(0.0) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
point1:
				NeedsCleanup n1(1);
				cout << "Sleeping " << endl;
				Thread::sleep(1000);
point2:
				NeedsCleanup n2(2);
				cout << "Calculating" << endl;
				// A time-consuming, non-blocking operation
				for (int i = 1; i < 100000; i++)
				{
					d = d + (PI + E) / (double)i;
				}
				cout << "Exiting via while() test" << endl;
			}
		} catch (Interrupted_Exception& e) {
			cout << "Exiting via Interrupted_Exception" << endl;
		}
	}
};

int main(int argc, char* argv[]) {
	if (argc != 2){
		cerr << "usage: " << argv[0] << " delay-in-milliseconds" << endl;
		exit(1);
	}
	int delay = atoi(argv[1]);
	try {
		Thread t(new Blocked3);
		Thread::sleep(delay);
		t.interrupt();
	} catch (Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	在这个示例中，通过传递一个命令行参数作为延迟时间。使用不同的延迟，可以从循环中的不同地点退出`Blocked3::run()`函数：从正处于阻塞状态的`sleep()`调用中退出，以及从非阻塞状态的数学计算中退出。如果`interrupt()`在标签`point2`后被调用，首先循环已经完成，其次所有的本地对象被析构，最后循环经由`while`语句在顶部退出。然而，如果`interrupt()`在`point1`和`point2`之间被调用，任务通过`Interrupted_Exception`异常退出。在这种情况下，只有在异常被抛出的位置之前被创建完成的栈对象才会被清理，并且有机会在`catch`子句中完成其他的清理操作。

​	**设计用来响应interrupt()函数的类必须建立一种策略，以便保证其能够保持一致的状态。这通常意味着，所有的资源获取都要封装在基于栈的对象中，以便无论run()循环如何退出，对象的析构函数都会被调用。**

## 5 线程间协作

​	多个线程能够一起工作来共同解决某个问题，这就是线程间的协作。这些任务协作时的关键问题是这些任务间的握手。为完成这个握手过程，使用相同的基础：互斥机制，互斥机制在这种情况下可以保证只有一个任务响应信号。这就消除了任何可能的竞争条件。这里会看到一些任务间的握手问题，在握手期间会出现的问题，以及这些问题相应的解决方法。

### 5.1 等待和信号

​	在`ZThread`库中，使用互斥锁并允许任务挂起的基类是Condition，可以通过在条件Condition上调用wait()挂起一个任务。当外部状态发生改变时，这种改变也许意味着某个任务应该继续进行处理。调用信号函数signal()可以通知该任务而唤醒它，或者调用broadcast()，而唤醒所有在那个Condition对象上被挂起的任务。

​	wait()有两种形式。第一种形式接受一个毫秒作为参数，第二种形式不带参数。这两种形式的wait()都会释放被Condition对象所控制的互斥锁`Mutex`，并且会挂起线程直到Condition对象收到一个signal()或者broadcast()。如果超时，第一种形式在接收到signal()或者broadcast()之前也可以结束。

​	wait()会释放`Mutex`，意味着该`Mutex`可以被其他线程获得。相当于“现在已经做完了所有该做的事情，我将在此等待，但是我希望如果其他同步操作可以执行的允许它们执行”。

​	wait()在等待外部条件变化时挂起线程，只在signal()或者broadcast()被调用时，唤醒线程并检测发生的变化。因此，wait()为同步线程之间的活动提供了一种方法，避免了忙等待。

~~~c++
#include <iostream>
#include <string>
#include "zthread/Thread.h"
#include "zthread/Mutex.h"
#include "zthread/Guard.h"
#include "zthread/Condition.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

class Car {
	Mutex lock;
	Condition condition;
	bool waxOn;
public:
	Car() : condition(lock), waxOn(false) {}
	void waxed() {
		Guard<Mutex> g(lock);
		waxOn = true;	// Ready to buff
		condition.signal();
	}
	void buffed() {
		Guard<Mutex> g(lock);
		waxOn = false;	// Ready for another coat of wax
		condition.signal();
	}
	void waitForWaxing() {
		Guard<Mutex> g(lock);
		while (waxOn == false) {
			condition.wait();
		}
	}
	void waitForBuffing() {
		Guard<Mutex> g(lock);
		while (waxOn == true) {
			condition.wait();
		}
	}
};

class WaxOn : public Runnable {
	CountedPtr<Car> car;
public:
	WaxOn(CountedPtr<Car>& c) : car(c) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				cout << "Wax On!" << endl;
				Thread::sleep(200);
				car->waxed();
				car->waitForBuffing();
			}
		} catch (Interrupted_Exception&) {
			cout << "Ending Wax On process" << endl;
		}
	}
};

class WaxOff : public Runnable {
	CountedPtr<Car> car;
public:
	WaxOff(CountedPtr<Car>& c) : car(c) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				car->waitForWaxing();
				cout << "Wax Off!" << endl;
				Thread::sleep(200);
				car->buffed();
			}
		} catch (Interrupted_Exception&) {
			cout << "Ending Wax Off process" << endl;
		}
	}
};

int main() {
	cout << "Press <Enter> to quit" << endl;
	try {
		CountedPtr<Car> car(new Car);
		ThreadedExecutor executor;
		executor.execute(new WaxOff(car));
		executor.execute(new WaxOn(car));
		cin.get();
		executor.interrupt();
	} catch (Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	这里示例模拟了给汽车打蜡和抛光的过程：一个线程打蜡，一个线程抛光。抛光线程在打蜡线程完成前不能进行其工作，并且打蜡线程在汽车可以再穿一套蜡套之前必须等待抛光线程结束。

​	**尽管`Posix`线程不要求必须持有锁才能调用signal()或broadcast()，但这种做法是推荐的做法。**

​	wait()调用被置于一个while循环内部，用这个循环来检测相关的条件，主要基于以下两个原因：

- 很可能当某个线程得到一个信号signal()时，其他一些条件可能已经改变了，但这些条件在这里与调用wait()的原因无关。如果有这种情况，该线程在其相关的条件改变之前将再一次挂起。

- 在该线程从其wait()函数中醒来之时，可能另外某个任务改变了一些条件，因此这个线程就不能或者没兴趣在此时执行其操作了。它应再次调用wait()而被重新挂起。

  **这两个原因在调用wait()时总会出现，故总要编写在while循环内部调用wait()的一段程序来测试与线程相关的条件。**
  
  在一些平台上还有第三种方法跳出wait()，就是所谓的伪唤醒。一个伪唤醒本质上意味着一个线程过早地停止了阻塞，而没有被signal()或broadcast()激活。线程就像是自己醒过来一样。伪唤醒存在的原因是，在某些平台上实现`POSIX`线程或类似的东西，并不像它在某些平台上那样直截了当。对这些平台来说，允许伪唤醒能够简化建立类似`pthread`库的工作。`ZThread`库中不存在伪唤醒。
  
  ### 5.2 生产者-消费者关系

~~~c++
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "zthread/Thread.h"
#include "zthread/Mutex.h"
#include "zthread/Guard.h"
#include "zthread/Condition.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

// Apply jam to buttered toast
class Jammer : public Runnable {
	Mutex lock;
	Condition butteredToastReady;
	bool gotButteredToast;
	int jammed;
public:
	Jammer() : butteredToastReady(lock) {
		gotButteredToast = false;
		jammed = 0;
	}
	void moreButteredToastReady() {
		Guard<Mutex> g(lock);
		gotButteredToast = true;
		butteredToastReady.signal();
	}
	void run() {
		try {
			while (!Thread::interrupted()) {
				{
					Guard<Mutex> g(lock);
					while (!gotButteredToast) {
						butteredToastReady.wait();
					}
					++jammed;
				}
				cout << "Putting jam on toast " << jammed << endl;
				{
					Guard<Mutex> g(lock);
					gotButteredToast = false;
				}
			}
		} catch (Interrupted_Exception&) {
			cout << "Jammer off" << endl;
		}
	}
};

// Apply butter to toast
class Butterer : public Runnable {
	Mutex lock;
	Condition toastReady;
	CountedPtr<Jammer> jammer;
	bool gotToast;
	int buttered;
public:
	Butterer(CountedPtr<Jammer>& j) : toastReady(lock), jammer(j) {
		gotToast = false;
		buttered = 0;
	}
	void moreToastReady() {
		Guard<Mutex> g(lock);
		gotToast = true;
		toastReady.signal();
	}
	void run() {
		try {
			while (!Thread::interrupted()) {
				{
					Guard<Mutex> g(lock);
					while (!gotToast) {
						toastReady.wait();
					}
					++buttered;
				}
				cout << "Buttering toast " << buttered << endl;
				jammer->moreButteredToastReady();
				{
					Guard<Mutex> g(lock);
					gotToast = false;
				}
			}
		} catch (Interrupted_Exception&) {
			cout << "Butterer off" << endl;
		}
	}
};

class Toaster : public Runnable {
	CountedPtr<Butterer> butterer;
	int toasted;
public:
	Toaster(CountedPtr<Butterer>& b) : butterer(b) {
		toasted = 0;
	}
	void run() {
		try {
			while (!Thread::interrupted()) {
				Thread::sleep(rand() / (RAND_MAX / 5) * 100);
				// Create new toast...
				cout << "New toast " << ++toasted << endl;
				butterer->moreToastReady();
			}
		} catch (Interrupted_Exception&) {
			cout << "Toaster off" << endl;
		}
	}
}; 

int main() {
	srand(time(0));
	try {
		cout << "Press <Enter> to quit" << endl;
		CountedPtr<Jammer> jammer(new Jammer);
		CountedPtr<Butterer> butterer(new Butterer(jammer));
		ThreadedExecutor executor;
		executor.execute(new Toaster(butterer));
		executor.execute(butterer);
		executor.execute(jammer);
		cin.get();
		executor.interrupt();
	} catch (Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	这些类用逆序定义了三个任务：一个任务是制作烤面包，一个任务是给烤面包抹黄油，还有一个任务是往抹好黄油的面包上抹果酱。目的是简化前向引用的操作问题。

​	`Jammer`和`Butterer`都包含一个`Mutex`对象、一个`Condition`对象和一些内部状态信息。通过改变这些内部状态信息的状态，来指出进程要被挂起或恢复执行。`Toaster`不需要这些，因为它是生产者，无需等待任何事情。

​	这个程序在运行时可能会出错，因为会有许多片面包掉在地板上 - 没抹黄油，也没抹果酱。

### 5.3 用队列解决线程处理的问题

​	线程处理问题常常基于需要对任务进行串行化上，要使事情有序地进行处理。

~~~c++
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include "zthread/Thread.h"
#include "zthread/Mutex.h"
#include "zthread/Guard.h"
#include "zthread/Condition.h"
#include "zthread/ThreadedExecutor.h"
#include "TQueue.h"
using namespace ZThread;
using namespace std;

class Toast {
	enum Status { DRY, BUTTERED, JAMMED };
	Status status;
	int id;
public:
	Toast(int idn) : status(DRY), id(idn) {}
	void butter() { status = BUTTERED; }
	void jam() { status = JAMMED; }
	string getStatus() const {
		switch(status) {
		case DRY: return "dry";
		case BUTTERED: return "buttered";
		case JAMMED: return "jammed";
		default: return "error";
		}
	}
	int getId() { return id; }
	friend ostream& operator<<(ostream& os, const Toast& t) {
		return os << "Toast " << t.id << ": " << t.getStatus();
	}
};

typedef CountedPtr< TQueue<Toast> > ToastQueue;

class Toaster : public Runnable {
	ToastQueue toastQueue;
	int count;
public:
	Toaster(ToastQueue& tq) : toastQueue(tq), count(0) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				int delay = rand() / (RAND_MAX / 5) * 100;
				Thread::sleep(delay);
				// Make toast
				Toast t(count++);
				cout << t << endl;
				toastQueue->put(t);
			}
		} catch (Interrupted_Exception& ) {
			cout << "Toaster off" << endl;
		}
	}
};

// Apply butter to toast
class Butterer : public Runnable {
	ToastQueue dryQueue, butteredQueue;
public:
	Butterer(ToastQueue& dry, ToastQueue& buttered) : dryQueue(dry), butteredQueue(buttered) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				// Blocks until next piece of toast is available
				Toast t = dryQueue->get();
				t.butter();
				cout << t << endl;
				butteredQueue->put(t);
			}
		} catch (Interrupted_Exception& ) {
			cout << "Butterer off" << endl;
		}
	}
};

// Apply jam to buttered toast
class Jammer : public Runnable {
	ToastQueue butteredQueue, finishedQueue;
public:
	Jammer(ToastQueue& buttered, ToastQueue& finished) : butteredQueue(buttered), 
		finishedQueue(finished) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				// Blocks until next piece of toast is available
				Toast t = butteredQueue->get();
				t.jam(); 
				cout << t << endl;
				finishedQueue->put(t);
			}
		} catch (Interrupted_Exception& ) {
			cout << "Jammer off" << endl;
		}
	}
};

// Consume the toast
class Eater : public Runnable {
	ToastQueue finishedQueue;
	int counter;
public:
	Eater(ToastQueue& finished) : finishedQueue(finished), counter(0) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				// Blocks until next piece of toast is available
				Toast t = finishedQueue->get();
				// Verify that the toast is coming in order,
				// and that all pieces are jammed
				if (t.getId() != counter++ || t.getStatus() != "jammed") {
					cout << ">>>> Error: " << t << endl;
					exit(1);
				} else {
					cout << "Chomp! " << t << endl;
				}
			}
		} catch (Interrupted_Exception& ) {
			cout << "Eater off" << endl;
		}
	}
};

int main() {
	srand(time(0));
	try {
		ToastQueue dryQueue(new TQueue<Toast>),
			butteredQueue(new TQueue<Toast>),
			finishedQueue(new TQueue<Toast>);
		cout << "Press <Enter> to quit" << endl;
		ThreadedExecutor executor;
		executor.execute(new Toaster(dryQueue));
		executor.execute(new Butterer(dryQueue, butteredQueue));
		executor.execute(new Jammer(butteredQueue, finishedQueue));
		executor.execute(new Eater(finishedQueue));
		cin.get();
		executor.interrupt();
	} catch (Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	在这个解决方案中，两件事情会变得明显：

- 在每个Runnable类中代码的数量和复杂性通过队列`TQueue`的使用会显著减少，因此进行保护、通信，以及wait()/signal()操作现在都由`TQueue`来维护。Runnable类不再拥有任何`Mutex`或Condition对象。
- 类之间的耦合被消除了，因为每个类都只与它的`TQueue`通信。（现在类的定义次序是独立的。）

### 5.4 广播

~~~c++
#include <iostream>
#include <string>
#include "zthread/Thread.h"
#include "zthread/Mutex.h"
#include "zthread/Guard.h"
#include "zthread/Condition.h"
#include "zthread/ThreadedExecutor.h"
#include "TQueue.h"
using namespace ZThread;
using namespace std;

class Car {
	int id;
	bool engine, dirveTrain, wheels;
public:
	Car(int idn) : id(idn), engine(false), dirveTrain(false), wheels(false) {}
	Car() : id(-1), engine(false), dirveTrain(false), wheels(false) {}
	int getId() { return id; }
	void addEngine() { engine = true; }
	bool engineInstalled() { return engine; }
	void addDriveTrain() { dirveTrain = true; }
	bool driveTrainInstalled() { return dirveTrain; }
	void addWheels() { wheels = true; }
	bool wheelsInstalled() { return wheels; }
	friend ostream& operator<<(ostream& os, const Car& c) {
		return os << "Car " << c.id << " [" 
			<< " engine: " << c.engine
			<< " driveTrain: " << c.dirveTrain
			<< " wheels: " << c.wheels << "]";
	}
};

typedef CountedPtr< TQueue<Car> > CarQueue;

class ChassisBuilder : public Runnable {
	CarQueue carQueue;
	int counter;
public:
	ChassisBuilder(CarQueue& cq) : carQueue(cq), counter(0) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				Thread::sleep(1000);
				// Make chassis
				Car c(counter++);
				cout << c << endl;
				carQueue->put(c);
			}
		} catch (Interrupted_Exception& ) {
			cout << "ChassisBuilder off" << endl;
		}
	}
};

class Cradle {
	Car c;	// Holds current car begin worked on
	bool occupied;
	Mutex workLock, readyLock;
	Condition workCondition, readyCondition;
	bool engineBotHired, driveTrainBotHired, wheelBotHired;
public:
	Cradle() : workCondition(workLock), readyCondition(readyLock) {
		occupied = false;
		engineBotHired = true;
		driveTrainBotHired = true;
		wheelBotHired = true;
	}
	void insertCar(Car chassis) {
		c = chassis;
		occupied = true;
	}
	Car getCar() {	// can only extract car once
		if (!occupied) {
			cerr << "No Car in Cradle for getCar()" << endl;
			return Car();
		}
		occupied = false;
		return c;
	}
	// Access car while in cardle
	Car* operator->() { return &c; }
	// Allow robots to offer services to this cradle
	void offerEngineBotServices() {
		Guard<Mutex> g(workLock);
		while(engineBotHired) {
			workCondition.wait();
		}
		engineBotHired = true;
	}
	void offerWheelBotServies() {
		Guard<Mutex> g(workLock);
		while(wheelBotHired) {
			workCondition.wait();
		}
		wheelBotHired = true;
	}
	void offerDriveTrainBotServies() {
		Guard<Mutex> g(workLock);
		while(driveTrainBotHired) {
			workCondition.wait();
		}
		driveTrainBotHired = true;
	}
	// Tell waiting robots that work is ready
	void startWork() {
		Guard<Mutex> g(workLock);
		engineBotHired = false;
		wheelBotHired = false;
		driveTrainBotHired = false;
		workCondition.broadcast();
	}
	// Each robot reports when their job is done
	void taskFinished() {
		Guard<Mutex> g(readyLock);
		readyCondition.signal();
	}
	// Directors waits until all jobs are done
	void waitUntilWorkFinished() {
		Guard<Mutex> g(readyLock);
		while(!(c.engineInstalled() && c.driveTrainInstalled() && c.wheelsInstalled())) {
			readyCondition.wait();
		}
	}
};

typedef CountedPtr<Cradle> CradlePtr;

class Director : public Runnable {
	CarQueue chassisQueue, finishingQueue;
	CradlePtr cradle;
public:
	Director(CarQueue& cq, CarQueue& fq, CradlePtr& cr) 
		: chassisQueue(cq), finishingQueue(fq), cradle(cr) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				// Blocks until chassis is available
				cradle->insertCar(chassisQueue->get());
				// Notify robots car is ready for work
				cradle->startWork();
				// Wait until work completes
				cradle->waitUntilWorkFinished();
				// Put car into queue for further work
				finishingQueue->put(cradle->getCar());
			}
		} catch (Interrupted_Exception& ) {
			cout << "Director off" << endl;
		}
	}
};

class EngineRobot : public Runnable {
	CradlePtr cradle;
public:
	EngineRobot(CradlePtr& cr) : cradle(cr) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				// Blocks until job is offered/accepted
				cradle->offerEngineBotServices();
				cout << "Installing engine" << endl;
				(*cradle)->addEngine();
				cradle->taskFinished();
			}
		} catch (Interrupted_Exception& ) {
			cout << "EngineRobot off" << endl;
		}
	}
};

class DriveTrainRobot : public Runnable {
	CradlePtr cradle;
public:
	DriveTrainRobot(CradlePtr& cr) : cradle(cr) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				// Blocks until job is offered/accepted
				cradle->offerDriveTrainBotServies();
				cout << "Installing DriveTrain" << endl;
				(*cradle)->addDriveTrain();
				cradle->taskFinished();
			}
		} catch (Interrupted_Exception& ) {
			cout << "DriveTrainRobot off" << endl;
		}
	}
};

class WheelRobot : public Runnable {
	CradlePtr cradle;
public:
	WheelRobot(CradlePtr& cr) : cradle(cr) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				// Blocks until job is offered/accepted
				cradle->offerWheelBotServies();
				cout << "Installing Wheel" << endl;
				(*cradle)->addWheels();
				cradle->taskFinished();
			}
		} catch (Interrupted_Exception& ) {
			cout << "WheelRobot off" << endl;
		}
	}
};

class Reporter : public Runnable {
	CarQueue carQueue;
public:
	Reporter(CarQueue& cq) : carQueue(cq) {}
	void run() {
		try {
			while (!Thread::interrupted()) {
				cout << carQueue->get() << endl;
			}
		} catch (Interrupted_Exception& ) {
			cout << "Reporter off" << endl;
		}
	}
};

int main() {
	cout << "Press <Enter> to quit" << endl;
	try {
		CarQueue chassisQueue(new TQueue<Car>),
			finishingQueue(new TQueue<Car>);
		CradlePtr cradle(new Cradle);
		ThreadedExecutor executor;
		executor.execute(new EngineRobot(cradle));
		executor.execute(new DriveTrainRobot(cradle));
		executor.execute(new WheelRobot(cradle));
		executor.execute(new Director(chassisQueue, finishingQueue, cradle));
		executor.execute(new Reporter(finishingQueue));
		// Start everything running by producing chassis
		executor.execute(new ChassisBuilder(chassisQueue));
		cin.get();
		executor.interrupt();
	} catch (Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	`ChassisBuilder`只是每秒钟创建一个新的Car，把它放入`chassisQueue`队列中。Director通过把下一个Car从`chassisQueue`队列中取出，把它放入Cradle，而通知所有机器人去`startWork()`，并通过调用`waitUntilWorkFinished()`挂起自己等一系列操作来管理装配进程。当工作完成时，Director把Car从Cradle中取出并放入`finishingQueue`。

​	Cradle是发送信号操作的关键。互斥锁`Mutex`和Condition条件对象控制着两件事情：机器人进行的工作和显示所有的操作是否已经完成。一个特定类型的机器人能够通过调用与其类型相适应的提供函数将其服务提供给Cradle。在这个地方，机器人线程被挂起，直到Director调用开始工作函数`startWork()`，它改变雇佣标志并调用broadcast()来通知所有机器人出来工作。

​	当Director将一个Car插入到Cradle中时，可以通过运算符operator->()在Car上执行操作。为了防止多次提取同一辆汽车，用一个标志引发产生一个错误报告。

## 6 死锁

​	仔细设计程序来预防死锁是开发并发程序的一个关键的要素。哲学家就餐问题是一个关于死锁的经典问题。该问题的基本描述指定了5个哲学家围坐在桌子周围，哲学家与哲学家之间放一根筷子。当一个哲学家想就餐时，他必须同时得到他左边的那根筷子和右边的那根筷子。如果该哲学家的旁边有人正在使用他所需要的筷子，那么这个哲学家就必须等待，直到所需要的筷子变成可用的。

**`DiningPhilosophers.h:`**

~~~c++
#ifndef DININGPHILOSOPHERS_H
#define DININGPHILOSOPHERS_H

#include <iostream>
#include <string>
#include <cstdlib>
#include "zthread/Condition.h"
#include "zthread/Mutex.h"
#include "zthread/Guard.h"
#include "zthread/Thread.h"
#include "Display.h"
using namespace ZThread;
using namespace std;

class Chopstick {
	Mutex lock;
	Condition notToken;
	bool taken;
public:
	Chopstick() : notToken(lock), taken(false) {}
	void take() {
		Guard<Mutex> g(lock);
		while (taken)
		{
			notToken.wait();
		}
		taken = true;
	}
	void drop() {
		Guard<Mutex> g(lock);
		taken = false;
		notToken.signal();
	}
};

class Philosopher : public Runnable {
	Chopstick& left;
	Chopstick& right;
	int id;
	int ponderFactor;
	CountedPtr<Display> display;
	int randSleepTime() {
		if (ponderFactor == 0) {
			return 0;
		}
		return rand() / (RAND_MAX / ponderFactor) * 250;
	}
	void output(string s) {
		ostringstream os;
		os << *this << " " << s << endl;
		display->output(os);
	}
public:
	Philosopher(Chopstick& l, Chopstick& r, CountedPtr<Display>& disp, int ident, int ponder)
		: left(l), right(r), display(disp), id(ident), ponderFactor(ponder) {}
	virtual void run() {
		try {
			while(!Thread::interrupted()) {
				output("thinking...");
				Thread::sleep(randSleepTime());
				// Hungry
				output("grabbing right");
				right.take();
				output("grabbing left");
				left.take();
				output("eating...");
				Thread::sleep(randSleepTime());
				right.drop();
				left.drop();
			}
		} catch(Synchronization_Exception& e) {
			output(e.what());
		}
	}
	friend ostream& operator<<(ostream& os, const Philosopher& p) {
		return os << "Philosopher " << p.id;
	}
};

#endif
~~~

**`DeadlockingDiningPhilosophers.h:`**

~~~c++
#include <ctime>
#include "DiningPhilosophers.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

int main(int argc, char* argv[]) {
	srand(time(0));
	int ponder = argc > 1 ? atoi(argv[1]) : 5;
	cout << "Press <Enter> to quit" << endl;
	enum { SZ = 5 };
	try {
		CountedPtr<Display> display(new Display);
		ThreadedExecutor executor;
		Chopstick c[SZ];
		for (int i = 0; i < SZ; ++i)
		{
			executor.execute(new Philosopher(c[i], c[(i+1) % SZ], display, i, ponder));
		}
		cin.get();
		executor.interrupt();
		executor.wait();
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	如果`Philosopher`花很少的时间进行思考，当他们试图进餐时都来对`Chopstick`进行竞争，死锁就会更快的发生。

​	如果同时满足以下4个条件，死锁就会发生：

- 相互排斥。线程使用的资源至少有一个必须是不可共享的。在这种情况下，一根筷子一次就只能被一个哲学家使用。

- 至少有一个线程必须持有某一种资源，并且同时在等待获得正在被另外的线程所持有的资源。也就是说，要发生死锁一个哲学家必须持有一根筷子并且等待另一根筷子。

- 不能以抢占的方式剥夺一个线程的资源。所有的线程只能把释放资源作为一个正常事件。哲学家不会从别的哲学家手中抢夺筷子。

- 出现一个循环等待，一个线程等待另外的线程持有的资源，而这个被等待的线程又等待另一个线程所持有的资源，以此类推直到某个线程去等待第一个线程所持有的资源。

  必须所有这些条件都满足才会引发死锁，那么只需阻止其中一个条件发生就可以防止产生死锁。在这个程序中，防止死锁最容易的办法就是破坏条件四。如果最后一个哲学家被初始化为先尝试拿左边的筷子，然后再拿右边的筷子，那么该哲学家将永远无法阻止右边紧挨着的哲学家拿到他自己左边的筷子。在这种情形下，就防止了循环等待。这只是问题的一种解决方法，也可以通过阻止其他条件发生来解决这个问题。

**`FixedDiningPhilosophers.cpp:`**

~~~c++
#include <ctime>
#include "DiningPhilosophers.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

int main(int argc, char* argv[]) {
	srand(time(0));
	int ponder = argc > 1 ? atoi(argv[1]) : 5;
	cout << "Press <Enter> to quit" << endl;
	enum { SZ = 5 };
	try {
		CountedPtr<Display> display(new Display);
		ThreadedExecutor executor;
		Chopstick c[SZ];
		for (int i = 0; i < SZ; ++i)
		{
			if (i < (SZ - 1)) {
				executor.execute(new Philosopher(c[i], c[(i+1) % SZ], display, i, ponder));
			} else {
				executor.execute(new Philosopher(c[0], c[i], display, i, ponder));
			}
		}
		cin.get();
		executor.interrupt();
		executor.wait();
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	**没有编程语言上的支持可以帮助防止死锁；这取决于你是否能通过谨慎的设计来避免死锁。**