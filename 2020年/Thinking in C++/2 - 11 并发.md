# 2 - 11 并发

​	本文使用`ZThread`库，以传达线程处理的基本思想。

## 1、`ZThread`库在Windows平台上的编译方法

- 从官网上下载`ZThread`库的最新版本；
- 使用`VS2010`新建一个空白的静态库项目；
- 将`ZThread`库中的`include`目录设为包含目录；
- 将`ZThread`库中的`src`目录中的文件引入项目中；
- 使用`VS2010`进行编译；

**编译动态库的方法类似。**

## 2 `ZThread`库的使用示例

~~~c++
class LiftOff : public ZThread::Runnable {
	int countDown;
	int id;

public:
	LiftOff(int count, int ident = 0)
		: countDown(count), id(ident){}

	~LiftOff(){
		std::cout << id << " completed" << std::endl;
	}

	void run() {
		while (countDown--) {
			std::cout << id << ":" << countDown << std::endl;
		}
		std::cout << "LiftOff!" << std::endl;
	}
};
~~~

### 2.1 普通用法

~~~c++
#include <iostream>
#include "LiftOff.h"
#include "zthread/Thread.h"
using namespace ZThread;
using namespace std;

int main() {
	const int SZ = 5;
	try {
		for (int i = 0; i < SZ; ++i){
			Thread t(new LiftOff(10, i));
		}
		cout << "Waiting for LiftOff" << endl;
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
	return 0;
}
~~~

### 2.2 使用执行器简化工作

**`ThreadedExecutor:`**

~~~c++
#include <iostream>
#include "zthread/ThreadedExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		ThreadedExecutor executor;
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	`ThreadedExecutor`为需要运行的每个任务都创建了一个线程，用一个不同类型的`Executor`对象来代替`ThreadedExecutor`对象，就可以容易的改变任务的执行方式。使用`PoolExecutor`对象来替换`ThreadedExecutor`对象，它使用一个有限的线程集以并行的方式执行提交的任务。

**`PoolExecutor:`**

~~~c++
#include <iostream>
#include "zthread/PoolExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		PoolExecutor executor(5);
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	使用`PoolExecutor`，可以预先将开销很大的线程分配工作一次做完，在可能的时候重用这些线程。这样做会节省时间，因为不会因不断地为了每个任务都创建一个线程而付出那些开销。并且在一个事件驱动的系统中，对于一些需要由线程来处理的事件，可以以很快的方式产生。而这些快速产生的线程可以仅从线程池中取出线程的方式来提供。

**`ConcurrentExecutor:`**

~~~c++
#include <iostream>
#include "zthread/ConcurrentExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		ConcurrentExecutor executor;
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	`ConcurrentExecutor`类就像是一个`PoolExecutor`类，该类有大小固定的一个线程。对于需要在另一个线程中不断运行的任务(长期处于活动状态的任务)来说，或者需要在线程中运行的短任务来说，这个类是很有用的。

​	如果有多个任务被提交至一个`ConcurrentExecutor`，每个任务都会在下一个任务开始之前执行完成，所有的任务都使用同一个线程。`ConcurrentExecutor`串行化执行提交给它的任务。

**`SynchronousExecutor:`**

~~~c++
#include <iostream>
#include "zthread/SynchronousExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		SynchronousExecutor executor;
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		} 
	} catch (Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	类似`ConcurrentExecutor`，`SynchronousExecuror`用于需要同一时刻只执行一个任务的时候，串行代替了并发。`SynchronousExecuror`自己不创建或管理线程。它使用提交任务的线程，因此只会作为同步的焦点来行动。如果有n个线程向`SynchronousExecuror`提交了任务，永远不会同一时刻运行两个任务。另外，每个任务完成以后，队列里的下一个任务才会开始执行。

### 2.3 让步(yield)

​	可以调用`yield()`函数给线程调度机制一个暗示，现在已经做完了该做的工作，可以让其他线程使用CPU了。这个暗示仅仅是一个暗示，不能保证所实现的系统会监听到它。一般情况下，`yield()`只在极少的情形下有用处，不能依赖它来对应用程序做出任何严谨的调整。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

class YieldingTask : public Runnable {
	int countDown;
	int id;

public:
	YieldingTask(int ident = 0) : countDown(5), id(ident) {}
	~YieldingTask() { cout << id << " completed" << endl; }
	
	friend ostream& operator<<(ostream& os, const YieldingTask& yt) {
		return os << "#" << yt.id << ": " << yt.countDown;
	}

	void run() {
		while(true) {
			cout << *this << endl;
			if (--countDown == 0) {
				return;
			}
			Thread::yield();
		}
	}
};

int main() {
	try {
		ThreadedExecutor executor;
		for (int i = 0; i < 5; ++i){
			executor.execute(new YieldingTask(i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

### 2.4 休眠(sleep)

​	调用函数`sleep()`，使线程根据给定的毫秒数停止执行一段时间，也可以控制线程行为。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

class SleepingTask : public Runnable {
	int countDown;
	int id;

public:
	SleepingTask(int ident = 0) : countDown(5), id(ident) {}
	~SleepingTask() { cout << id << " completed" << endl; }

	friend ostream& operator<<(ostream& os, const SleepingTask& yt) {
		return os << "#" << yt.id << ": " << yt.countDown;
	}

	void run() {
		while(true) {
			try {
				cout << *this << endl;
				if (--countDown == 0) {
					return;
				}
				Thread::sleep(100);
			} catch (Interrupted_Exception& e) {
				cerr << e.what() << endl;
			}
		}
	}
};

int main() {
	try {
		ThreadedExecutor executor;
		for (int i = 0; i < 5; ++i){
			executor.execute(new SleepingTask(i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	**`Thread::sleep()`可以跑出一个`Interrupted_Exception`异常，这个异常在`run()`中被捕获，是因为异常不会跨越线程传播倒退回`main()`中。因此，必须对可能在任务中出现的任何局部性异常进行处理。**

​	`sleep()`也不是一个控制线程执行顺序的办法。它仅会让线程的执行停止片刻。只能保证线程至少休眠给定的时间，但线程恢复执行前可能需要更多的时间，因为在休眠间歇期过后，线程调度器还需要时间来恢复它。

​	**如果必须要控制线程的执行顺序，最好的办法是使用同步控制，或者在某些情况下，根本不使用线程，而是自己编写以特定的顺序相互控制的协作子例程。**

### 2.5 优先权

​	线程优先权向线程调度器传达一个线程的重要性。虽然CPU以一个不确定的顺序运行一个线程集，但是在这些等待的线程中，线程调度器将倾向于先运行有最高优先权的等待线程，有较低优先权的线程运行较少。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
using namespace ZThread;
using namespace std;

const double pi = 3.14159265358979323846;
const double e = 2.7182818284590452354;

class SimplePriorities : public Runnable {
	int countDown;
	volatile double d;
	int id;
public:
	SimplePriorities(int ident = 0) : countDown(5), id(ident) {}
	~SimplePriorities() { cout << id << " completed" << endl; }

	friend ostream& operator<<(ostream& os, const SimplePriorities& sp) {
		return os << "#" << sp.id << " priority: " << Thread().getPriority()
			<< " count: " << sp.countDown;
	}

	void run() {
		while (true) {
			for (int i = 1; i < 100000; ++i)
			{
				d = d + (pi + e) / double(i);
			}
			cout << *this << endl;
			if (--countDown) {
				return;
			}
		}
	}
};

int main() {
	try {
		Thread high(new SimplePriorities);
		high.setPriority(High);
		for (int i = 0; i < 5; ++i) {
			Thread low(new SimplePriorities(i));
			low.setPriority(Low);
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	将优先权映射到操作系统的做法是有问题的。只有将优先权级别划分成非常大的粒度才是一个接近实用的方法。

## 3 共享有限的资源

​	使用多线程进行处理时，可能有两个或更多个线程试图在同一时刻使用同一个资源。这就可能引起两种不同的问题：必须的资源可能不存在；两个或更多的线程在其试图同时访问同一个资源时可能会发生冲突。

### 3.1 保证对象的存在

​	`ZThread`中的`Runnable`任务被`ZThread`库机制自动地进行了引用计数。任务一直维持到该任务的引用计数归零，此时才能删除该任务。即必须总是动态的删除任务，所以`Runnable`不能在栈上创建，必须总是用`new`来创建。

​	为了保证在这些任务之间任何被共享的对象要长期存在，就可以把对象放置在堆上。并且确保直到没有其他对象使用它时才能被销毁。`ZThread`库包含一个名叫`CountedPtr`的模板，它自动执行引用计数并在引用计数归零时用`delete`删除一个对象。

​	每当有对象被多于一个任务使用时，几乎总是需要使用`CountedPtr`模板来管理那些对象，以防由对象生存期争端而产生的问题。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/CountedPtr.h"
using namespace ZThread;
using namespace std;

class Count {
	enum { SZ = 100 };
	int n[SZ];
public:
	void increment() {
		for (int i = 0; i < SZ; ++i) {
			n[i]++;
		}
	}
};

class Incrementer : public Runnable {
	CountedPtr<Count> count;
public:
	Incrementer(const CountedPtr<Count>& c) : count(c) {}
	void run() {
		for (int n = 100; n > 0; n--) {
			Thread::sleep(250);
			count->increment();
		}
	}
};

int main() {
	CountedPtr<Count> count(new Count);
	try {
		Thread t0(new Incrementer(count));
		Thread t1(new Incrementer(count));
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

