# 2 - 11 并发

​	本文使用`ZThread`库，以传达线程处理的基本思想。

## 1、`ZThread`库在Windows平台上的编译方法

- 从官网上下载`ZThread`库的最新版本；
- 使用`VS2010`新建一个空白的静态库项目；
- 将`ZThread`库中的`include`目录设为包含目录；
- 将`ZThread`库中的`src`目录中的文件引入项目中；
- 使用`VS2010`进行编译；

**编译动态库的方法类似。**

## 2 `ZThread`库的使用示例

~~~c++
class LiftOff : public ZThread::Runnable {
	int countDown;
	int id;

public:
	LiftOff(int count, int ident = 0)
		: countDown(count), id(ident){}

	~LiftOff(){
		std::cout << id << " completed" << std::endl;
	}

	void run() {
		while (countDown--) {
			std::cout << id << ":" << countDown << std::endl;
		}
		std::cout << "LiftOff!" << std::endl;
	}
};
~~~

### 2.1 普通用法

~~~c++
#include <iostream>
#include "LiftOff.h"
#include "zthread/Thread.h"
using namespace ZThread;
using namespace std;

int main() {
	const int SZ = 5;
	try {
		for (int i = 0; i < SZ; ++i){
			Thread t(new LiftOff(10, i));
		}
		cout << "Waiting for LiftOff" << endl;
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
	return 0;
}
~~~

### 2.2 使用执行器简化工作

**`ThreadedExecutor:`**

~~~c++
#include <iostream>
#include "zthread/ThreadedExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		ThreadedExecutor executor;
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	`ThreadedExecutor`为需要运行的每个任务都创建了一个线程，用一个不同类型的`Executor`对象来代替`ThreadedExecutor`对象，就可以容易的改变任务的执行方式。使用`PoolExecutor`对象来替换`ThreadedExecutor`对象，它使用一个有限的线程集以并行的方式执行提交的任务。

**`PoolExecutor:`**

~~~c++
#include <iostream>
#include "zthread/PoolExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		PoolExecutor executor(5);
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	使用`PoolExecutor`，可以预先将开销很大的线程分配工作一次做完，在可能的时候重用这些线程。这样做会节省时间，因为不会因不断地为了每个任务都创建一个线程而付出那些开销。并且在一个事件驱动的系统中，对于一些需要由线程来处理的事件，可以以很快的方式产生。而这些快速产生的线程可以仅从线程池中取出线程的方式来提供。

**`ConcurrentExecutor:`**

~~~c++
#include <iostream>
#include "zthread/ConcurrentExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		ConcurrentExecutor executor;
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	`ConcurrentExecutor`类就像是一个`PoolExecutor`类，该类有大小固定的一个线程。对于需要在另一个线程中不断运行的任务(长期处于活动状态的任务)来说，或者需要在线程中运行的短任务来说，这个类是很有用的。

​	如果有多个任务被提交至一个`ConcurrentExecutor`，每个任务都会在下一个任务开始之前执行完成，所有的任务都使用同一个线程。`ConcurrentExecutor`串行化执行提交给它的任务。

**`SynchronousExecutor:`**

~~~c++
#include <iostream>
#include "zthread/SynchronousExecutor.h"
#include "LiftOff.h"
using namespace ZThread;
using namespace std;

int main() {
	try {
		SynchronousExecutor executor;
		for (int i = 0; i < 5; ++i)
		{
			executor.execute(new LiftOff(10, i));
		} 
	} catch (Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	类似`ConcurrentExecutor`，`SynchronousExecuror`用于需要同一时刻只执行一个任务的时候，串行代替了并发。`SynchronousExecuror`自己不创建或管理线程。它使用提交任务的线程，因此只会作为同步的焦点来行动。如果有n个线程向`SynchronousExecuror`提交了任务，永远不会同一时刻运行两个任务。另外，每个任务完成以后，队列里的下一个任务才会开始执行。

### 2.3 让步(yield)

​	可以调用`yield()`函数给线程调度机制一个暗示，现在已经做完了该做的工作，可以让其他线程使用CPU了。这个暗示仅仅是一个暗示，不能保证所实现的系统会监听到它。一般情况下，`yield()`只在极少的情形下有用处，不能依赖它来对应用程序做出任何严谨的调整。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

class YieldingTask : public Runnable {
	int countDown;
	int id;

public:
	YieldingTask(int ident = 0) : countDown(5), id(ident) {}
	~YieldingTask() { cout << id << " completed" << endl; }
	
	friend ostream& operator<<(ostream& os, const YieldingTask& yt) {
		return os << "#" << yt.id << ": " << yt.countDown;
	}

	void run() {
		while(true) {
			cout << *this << endl;
			if (--countDown == 0) {
				return;
			}
			Thread::yield();
		}
	}
};

int main() {
	try {
		ThreadedExecutor executor;
		for (int i = 0; i < 5; ++i){
			executor.execute(new YieldingTask(i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

### 2.4 休眠(sleep)

​	调用函数`sleep()`，使线程根据给定的毫秒数停止执行一段时间，也可以控制线程行为。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

class SleepingTask : public Runnable {
	int countDown;
	int id;

public:
	SleepingTask(int ident = 0) : countDown(5), id(ident) {}
	~SleepingTask() { cout << id << " completed" << endl; }

	friend ostream& operator<<(ostream& os, const SleepingTask& yt) {
		return os << "#" << yt.id << ": " << yt.countDown;
	}

	void run() {
		while(true) {
			try {
				cout << *this << endl;
				if (--countDown == 0) {
					return;
				}
				Thread::sleep(100);
			} catch (Interrupted_Exception& e) {
				cerr << e.what() << endl;
			}
		}
	}
};

int main() {
	try {
		ThreadedExecutor executor;
		for (int i = 0; i < 5; ++i){
			executor.execute(new SleepingTask(i));
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	**`Thread::sleep()`可以跑出一个`Interrupted_Exception`异常，这个异常在`run()`中被捕获，是因为异常不会跨越线程传播倒退回`main()`中。因此，必须对可能在任务中出现的任何局部性异常进行处理。**

​	`sleep()`也不是一个控制线程执行顺序的办法。它仅会让线程的执行停止片刻。只能保证线程至少休眠给定的时间，但线程恢复执行前可能需要更多的时间，因为在休眠间歇期过后，线程调度器还需要时间来恢复它。

​	**如果必须要控制线程的执行顺序，最好的办法是使用同步控制，或者在某些情况下，根本不使用线程，而是自己编写以特定的顺序相互控制的协作子例程。**

### 2.5 优先权

​	线程优先权向线程调度器传达一个线程的重要性。虽然CPU以一个不确定的顺序运行一个线程集，但是在这些等待的线程中，线程调度器将倾向于先运行有最高优先权的等待线程，有较低优先权的线程运行较少。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
using namespace ZThread;
using namespace std;

const double pi = 3.14159265358979323846;
const double e = 2.7182818284590452354;

class SimplePriorities : public Runnable {
	int countDown;
	volatile double d;
	int id;
public:
	SimplePriorities(int ident = 0) : countDown(5), id(ident) {}
	~SimplePriorities() { cout << id << " completed" << endl; }

	friend ostream& operator<<(ostream& os, const SimplePriorities& sp) {
		return os << "#" << sp.id << " priority: " << Thread().getPriority()
			<< " count: " << sp.countDown;
	}

	void run() {
		while (true) {
			for (int i = 1; i < 100000; ++i)
			{
				d = d + (pi + e) / double(i);
			}
			cout << *this << endl;
			if (--countDown) {
				return;
			}
		}
	}
};

int main() {
	try {
		Thread high(new SimplePriorities);
		high.setPriority(High);
		for (int i = 0; i < 5; ++i) {
			Thread low(new SimplePriorities(i));
			low.setPriority(Low);
		}
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	将优先权映射到操作系统的做法是有问题的。只有将优先权级别划分成非常大的粒度才是一个接近实用的方法。

## 3 共享有限的资源

​	使用多线程进行处理时，可能有两个或更多个线程试图在同一时刻使用同一个资源。这就可能引起两种不同的问题：必须的资源可能不存在；两个或更多的线程在其试图同时访问同一个资源时可能会发生冲突。

### 3.1 保证对象的存在

​	`ZThread`中的`Runnable`任务被`ZThread`库机制自动地进行了引用计数。任务一直维持到该任务的引用计数归零，此时才能删除该任务。即必须总是动态的删除任务，所以`Runnable`不能在栈上创建，必须总是用`new`来创建。

​	为了保证在这些任务之间任何被共享的对象要长期存在，就可以把对象放置在堆上。并且确保直到没有其他对象使用它时才能被销毁。`ZThread`库包含一个名叫`CountedPtr`的模板，它自动执行引用计数并在引用计数归零时用`delete`删除一个对象。

​	每当有对象被多于一个任务使用时，几乎总是需要使用`CountedPtr`模板来管理那些对象，以防由对象生存期争端而产生的问题。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/CountedPtr.h"
using namespace ZThread;
using namespace std;

class Count {
	enum { SZ = 100 };
	int n[SZ];
public:
	void increment() {
		for (int i = 0; i < SZ; ++i) {
			n[i]++;
		}
	}
};

class Incrementer : public Runnable {
	CountedPtr<Count> count;
public:
	Incrementer(const CountedPtr<Count>& c) : count(c) {}
	void run() {
		for (int n = 100; n > 0; n--) {
			Thread::sleep(250);
			count->increment();
		}
	}
};

int main() {
	CountedPtr<Count> count(new Count);
	try {
		Thread t0(new Incrementer(count));
		Thread t1(new Incrementer(count));
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

#### 3.2 不恰当的访问资源

​	竞争条件，即两个或更多的任务竞争着响应同一个条件，因此发生冲突，或者没有发生冲突却产生不一致的结果。必须仔细考虑以防所有可能会使并发系统崩溃的情形发生。例如，一个任务不能依赖于其他任务，因为不能保证任务停止的顺序。这里使用一个例子，由共享公共资源(`Cancelable Generator`)的任务监视着该资源，以便根据标志来结束监视，使任务依赖于非任务对象，消除了潜在的竞争条件。

**`EvenChecker.h`:**

~~~c++
#include <iostream>
#include "zthread/CountedPtr.h"
#include "zthread/Thread.h"
#include "zthread/Cancelable.h"
#include "zthread/ThreadedExecutor.h"

class Generator : public ZThread::Cancelable {
	bool canceled;
public:
	Generator() : canceled(false) {}
	virtual int nextValue() = 0;
	void cancel() { canceled = true; }
	bool isCanceled() { return canceled; }
};

class EvenChecker : public ZThread::Runnable {
	ZThread::CountedPtr<Generator> generator;
	int id;
public:
	EvenChecker(ZThread::CountedPtr<Generator>& g, int ident)
		: generator(g), id(ident) {}
	~EvenChecker() {
		std::cout << "~EvenChecker " << id << std::endl;
	}
	void run() {
		while(!generator->isCanceled()) {
			int val = generator->nextValue();
			if(val % 2 != 0) {
				std::cout << val << " not even!" << std::endl;
				generator->cancel();
			}
		}
	}

	template<typename GenType> static void test(int n = 10) {
		std::cout << "Press Control-C to exit" << std::endl;
		try {
			ZThread::ThreadedExecutor executor;
			ZThread::CountedPtr<Generator> gp(new GenType);
			for(int i = 0; i < n; ++i) {
				executor.execute(new EvenChecker(gp, i));
			}
		} catch(ZThread::Synchronization_Exception& e) {
			std::cerr << e.what() << std::endl;
		}
	}
};
~~~

**`EvenGenerator.cpp:`**

~~~c++
#include <iostream>
#include "EvenChecker.h"
#include "zthread/ThreadedExecutor.h"
using namespace ZThread;
using namespace std;

class EvenGenerator : public Generator {
	unsigned int currentEvenValue;
public:
	EvenGenerator() { currentEvenValue = 0; }
	~EvenGenerator() { cout << "~EvenGenerator" << endl; }
	int nextValue() {
		++currentEvenValue;
		++currentEvenValue;
		return currentEvenValue;
	}
};

int main() {
	EvenChecker::test<EvenGenerator>();
}
~~~

​	`Generator`类引入了抽象类`Cancelable`，它是`ZThread`库的一部分。`Cancelable`的目的是提供一个一致的接口，以便通过`cancel()`函数来改变对象的状态，用`isCanceled()`函数来检查对象是否已被取消。

#### 3.3 访问控制

​	对于多线程处理的工作，需要一些方法来防止两个线程同时访问一个资源，至少要防止两个线程在临界期内访问同一资源。通过互斥`Mutex`可以解决这个问题。

~~~c++
#include <iostream>
#include "EvenChecker.h"
#include "zthread/ThreadedExecutor.h"
#include "zthread/Mutex.h"
using namespace ZThread;
using namespace std;

class MutexEvenGenerator : public Generator {
	unsigned int currentEvenValue;
	Mutex lock;
public:
	MutexEvenGenerator() { currentEvenValue = 0; }
	~MutexEvenGenerator() { cout << "~MutexEvenGenerator" << endl; }
	int nextValue() {
		lock.acquire();
		++currentEvenValue;
		Thread::yield();
		++currentEvenValue;
		int rval = currentEvenValue;
		lock.release();
		return rval;
	}
};

int main() {
	EvenChecker::test<MutexEvenGenerator>();
}
~~~

​	这里增加了一个叫做`lock`的`Mutex`型变量，并且在`nextValue()`中使用了`acquire()`和`release()`来创建临界区。以这种方法，在同一时刻只有一个线程能够访问被互斥锁所保护的代码。

#### 3.4 使用保护简化编码

​	`ZThread`库以`Guard`模板的方式解决了发生异常或者返回路径过多时，使用互斥锁会很复杂的问题。`Guard`模板创建对象，当这些对象被创建时用`acquire()`函数获得一个`Lockable`对象；当这些`Guard`对象被销毁时，用`release()`函数释放该锁。

~~~c++
#include <iostream>
#include "EvenChecker.h"
#include "zthread/ThreadedExecutor.h"
#include "zthread/Mutex.h"
#include "zthread/Guard.h"
using namespace ZThread;
using namespace std;

class GuardedEvenGenerator : public Generator {
	unsigned int currentEvenValue;
	Mutex lock;
public:
	GuardedEvenGenerator() { currentEvenValue = 0; }
	~GuardedEvenGenerator() { cout << "~GuardedEvenGenerator" << endl; }
	int nextValue() {
		Guard<Mutex> g(lock);
		++currentEvenValue;
		Thread::yield();
		++currentEvenValue;
		return currentEvenValue;
	}
};

int main() {
	EvenChecker::test<GuardedEvenGenerator>();
}
~~~

​	`Guard`还可以被安全地用于操纵其他保护(`Gurad`)。下面程序中的第2个`Guard`可以用于临时解锁一个保护：

~~~c++
class TemporaryUnlocking {
    Mutex lock;
 public:
 	void f() {
        Guard<Mutex> g(lock);
        // lock is acquired
        {
            Guard<Mutex, UnlockedScope> h(g);
            // lock is released
            // ...
            // lock is acquired
        }
        // ...
        // lock is released
    }   
}
~~~

​	`Guard`也可以尝试在一个确定的时间内获得某个锁，然后放弃。下面程序中，如果在500豪秒内不能获得锁，就抛出一个`Timeout_Exception`异常：

~~~c++
class TimedLocking {
    Mutex lock;
public:
    void f() {
        Guard<Mutex, TimedLockedScope<500> > g(lock);
        // ...
    }
}
~~~

​	`ZThread`库还提供了一个`GuardedClass`模板来自动地为整个类创建同步封装器。这意味着该类中的每个成员函数都将自动被保护。

~~~c++
#include "zthread/GuardedClass.h"
using namespace ZThread;

class MyClass {
public:
    void f1() {}
    void f2() {}
};

int main() {
  MyClass a;
  a.f1();	// not synchronizied
  a.f2();	// not synchronizied
  GuardedClass<MyClass> b(new MyClass);
  b->f1();	
  b->f2();
}
~~~

​	对象a是非同步的，所有`f1()`和`f2()`能被任意个线程在任何时刻调用。对象b被`GuardedClass`封装器保护了起来，所以每个成员函数都被自动同步，在任意时刻每个对象仅由一个函数能被调用。

​	**封装器在类一级的粒度上加锁，可能会影响到它的性能。如果一个类包含某些互不相关的函数，也许用两种不同的锁在内部同步这些函数会更好一些。然而如果这样做了，则意味着该类也许包含非强相关的数据组。应该考虑把这个类分解成两个类。**

​	**用一个互斥锁包含一个类的所有成员函数并不能自动保证那个类是线程安全的。必须小心考虑所有的线程处理问题，以便保证线程的安全性。**

#### 3.5 线程本地存储

​	消除任务在共享资源上发生冲突问题的第2种解决办法是消除共享变量，对使用同一个对象的各个不同线程，可以为同一变量创建不同的存储单元。`ZThread`库的`ThreadLocal`模板自动创建和管理线程的本地存储。

~~~c++
#include <iostream>
#include "zthread/Thread.h"
#include "zthread/Mutex.h"
#include "zthread/Guard.h"
#include "zthread/ThreadedExecutor.h"
#include "zthread/Cancelable.h"
#include "zthread/ThreadLocal.h"
#include "zthread/CountedPtr.h"
using namespace ZThread;
using namespace std;

class ThreadLocalVariables : public Cancelable {
	ThreadLocal<int> value;
	bool canceled;
	Mutex lock;
public:
	ThreadLocalVariables() : canceled(false) {
		value.set(0);
	}
	void increment() { value.set(value.get() + 1); }
	int get() { return value.get(); }
	void cancel() {
		Guard<Mutex> g(lock);
		canceled = true;
	}
	bool isCanceled() {
		Guard<Mutex> g(lock);
		return canceled;
	}
};

class Accessor : public Runnable {
	int id;
	CountedPtr<ThreadLocalVariables> tlv;
public:
	Accessor(CountedPtr<ThreadLocalVariables>& tl, int ident) 
		: id(ident), tlv(tl) {}
	void run() {
		while (!tlv->isCanceled()) {
			tlv->increment();
			cout << *this << endl;
		}
	}
	friend ostream& operator<<(ostream& os, Accessor& a) {
		return os << "#" << a.id << ": " << a.tlv->get();
	}
};

int main() {
	cout << "Press <Enter> to quit" << endl;
	try {
		CountedPtr<ThreadLocalVariables> tlv(new ThreadLocalVariables);
		const int SZ = 5;
		ThreadedExecutor executor;
		for (int i = 0; i < SZ; ++i) {
			executor.execute(new Accessor(tlv, i));
		}
		cin.get();
		tlv->cancel();
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	当通过实例化`ThreadLocal`模板来创建对象时，只能用`get()`和`set()`成员函数访问该对象的内容。`get()`函数返回一份与那个线程相关联的对象的拷贝，而`set()`则将其参数插入到与那个线程相关的对象中存储，并返回存储单元中原来所保存的对象。

### 4 终止任务

#### 4.1 终止任务示例

​	这个程序说明了在结束多线程处理程序的执行时需要多么谨慎。

~~~c++
#include <vector>
#include <cstdlib>
#include <ctime>
#include "Display.h"
#include "zthread/Thread.h"
#include "zthread/FastMutex.h"
#include "zthread/Guard.h"
#include "zthread/ThreadedExecutor.h"
#include "zthread/CountedPtr.h"
using namespace ZThread;
using namespace std;

class Count : public Cancelable {
	FastMutex lock;
	int count;
	bool paused, canceled;
public:
	Count() : count(0), paused(false), canceled(false) {}
	int increment() {
		// Comment the following line to see counting fail
		Guard<FastMutex> g(lock);
		int temp = count;
		if (rand() % 2 == 0) { // yield half the time
			Thread::yield();
		}
		return (count = ++temp);
	}
	int value() {
		Guard<FastMutex> g(lock);
		return count;
	}
	void cancel() {
		Guard<FastMutex> g(lock);
		canceled = true;
	}
	bool isCanceled() {
		Guard<FastMutex> g(lock);
		return canceled;
	}
	void pause() {
		Guard<FastMutex> g(lock);
		paused = true;
	}
	bool isPaused() {
		Guard<FastMutex> g(lock);
		return paused;
	}
};

class Entrance : public Runnable {
	CountedPtr<Count> count;
	CountedPtr<Display> display;
	int number;
	int id;
	bool waitingForCancel;
public:
	Entrance(CountedPtr<Count>& cnt, CountedPtr<Display>& disp, int idn) 
		: count(cnt), display(disp), number(0), id(idn), waitingForCancel(false) {}
	void run() {
		while (!count->isPaused()) {
			++number;
			{
				ostringstream os;
				os << *this << " Total: " << count->increment() << endl;
				display->output(os);
			}
			Thread::sleep(100);
		}
		waitingForCancel = true;
		while (!count->isCanceled()) {
			Thread::sleep(100);
		}
		ostringstream os;
		os << "Terminating " << *this << endl;
		display->output(os);
	}
	int getValue() {
		while (count->isPaused() && !waitingForCancel) {
			Thread::sleep(100);
		}
		return number;
	}
	friend ostream& operator<<(ostream& os,const Entrance& e) {
		return os << "Entrance " << e.id << ": " << e.number;
	}
};

int main() {
	srand(time(0));
	cout << "Press <Enter> to quit" << endl;
	CountedPtr<Count> count(new Count);
	vector<Entrance*> v;
	CountedPtr<Display> display(new Display);
	const int SZ = 5;
	try {
		ThreadedExecutor executor;
		for (int i = 0; i < SZ; ++i) {
			Entrance* task = new Entrance(count, display, i);
			executor.execute(task);
			v.push_back(task);
		}
		cin.get();
		count->pause();	// Causes tasks to stop counting
		int sum = 0;
		vector<Entrance*>::iterator it = v.begin();
		while (it != v.end()) {
			sum += (*it)->getValue();
			++it;
		}
		ostringstream os;
		os << "Total: " << count->value() << endl 
			<< "Sum of Entrances: " << sum << endl;
		display->output(os);
		count->cancel();
	} catch(Synchronization_Exception& e) {
		cerr << e.what() << endl;
	}
}
~~~

​	`Count`是一个主计数器类，能够被所有的`Entrance`对象共享。这里还使用了一个`FastMutex`模板实例，`FastMutex`使用本地操作系统的互斥锁。

​	`Entrance`对象间所发生的所有通信都要通过一个`Count`对象。当用户按下`Enter`键时，`main()`函数用`pause()`发送消息给`count`。由于每个`Entrance::run()`都在监视着`count`对象是否暂停下来，这将引发每个`Entrance`对象迁移到`waitingForCancel`等待状态，在这种状态下它将不再计数，但仍然处于活动状态。这是必要的，因为`main()`必须能安全迭代在`vector<Entrance*>`中的每个对象。注意，因为在一个`Entrance`完成计数并迁移到`waitingForCancel`等待状态之前，发生迭代的可能性很小，可以忽略，所以函数`getValue()`循环调用`sleep()`直到对象迁移到`waitingForCancel`等待状态。(这种形式被称为忙等待，是不受欢迎的。可以使用`wait()`函数进行解决。)一旦`main()`函数完成了对`vector<Entrance*>`的一次遍历迭代，`cancel()`消息就会被传至`count`对象。所有`Entrance`对象都会监视这个状态变化。在这点上，它们打印一条终止信息并从`run()`中退出，这导致每个任务都会被线程处理机制销毁掉。

