# 正则表达式

​	正则表达式是处理拆分字符串并进行信息查找的过程。可以使用正则表达式解决各种任务：

- 操作`HTML`节点中的字符串；

- 使用`CSS`选择器表达式定位部分选择器；

- 判断一个元素是否具有指定的类名(`class`)；

- 输入校验；

- 其他任务；

  可以简单地将正则表达式理解为使用模式匹配文本字符串的表达式。表达式本身具有用于定义模式的术语和操作符。

  在`JavaScript`中，创建正则表达式有两种方式：

- 使用正则表达式字面量。`const pattern = /test/;`
- 通过创建`RegExp`对象的实例。`const pattern = new RegExp("test");`

**当正则表达式在开发环境中是明确的，推荐优先使用字面量语法；当需要在运行时动态创建字符串来构建正则表达式时，则使用构造函数的方式。**

​	正则表达式可以使用5个修饰符：

- `i - `对大小写不敏感，例如`/test/i`不仅可以匹配`test`，还可以匹配`Test`、`TEST`等；

- `g - `查找所有匹配项，在查找到第一个匹配时不会停止，会继续查找下一个匹配项；

- `m - `允许多行匹配，对获取`textarea`元素的值很有用；

- `y - `开启粘连匹配。正则表达式执行粘连匹配时试图从最后一个匹配的位置开始；

- `u - `允许使用`Unicode`点转义符(\u{...})；

  在字面量末尾添加修饰符(如`/test/g`)，或者作为第2个参数传给`RegExp`构造函数(如`new RegExp("test", "ig")`)。

## 1 术语和操作符

### 精确匹配

除了非特殊字符或操作符之外，字符必须准确出现在表达式中。一个接一个的字符直接连在一起，省略了操作符连接。如`/test/`中的4个字符，必须完全出现在所匹配的字符串中。

### 匹配字符集

匹配一组有限的字符集中的字符，可以将希望匹配的字符集放在`[]`中。如`[abc]`表示匹配a、b、c中的任意一个字符。

匹配一组有限字符集之外的任意字符，可以在左括号后面添加一个尖角号`^`。如`[^abc]`表示匹配除了a、b、c以外的任意字符。

匹配限定范围内的字符串集合，可以使用中横线`-`。如`[a-m]`表示匹配a和m之间的小写字母。

### 转义

并不是所有的字符和字符字面量都是等价的。如特殊字符$、。(.)匹配的是它们本身以外的内容，或者表示操作符。正则表达式中，反斜线对其后面的字符进行转义，使其匹配字符本身的含义。例如`\[`匹配`[`字符，而不再表示字符分组的括号。

### 起止符号

尖角号作为正则表达式的第一个字符时，用于匹配字符的开始，如`/^test/`匹配的是test出现在字符串的开头。美元符号`$`表示字符串的结束。同时使用`^`和`$`表示匹配整个字符串。

### 重复出现

正则表达式提供了以下几种用于指定重复选项的方式：

- 指定可选字符（可以出现0次或1次），在字符后添加`?`。

- 指定字符必须出现1次或多次，使用`+`。

- 指定字符出现0次或1次或多次，使用`*`。

- 指定重复次数，使用括号指定重复次数，例如`/a{4}/`匹配4个连续的字符a。

- 指定重复次数的范围，使用逗号分隔。例如`/a{4,10}`匹配4~10个连续的字符a。

- 指定开发区间，省略第2个值，保留逗号。例如`/a{4,}`匹配4个或更多个连续的字符a。

  这些运算符都可以是贪婪的或非贪婪的。默认是贪婪模式，可以匹配所有可能的字符，在运算符后加`?`，例如`a+?`，使得运算符为非贪婪模式，只进行最小限度的匹配。如对于字符串`aaa`，正则表达式`/a+/`会匹配全部3个字符，而非贪婪模式`/a+?/`则匹配一个字符a，因为一个字符a足以满足`a+`术语。

### 预定义字符集

有些希望匹配的内容无法通过字符字面量来表示（例如回车符）,有时我们还希望匹配字符集，例如一组十进制数字，或一组空格。正则表达式可以预定义表示这些字符或常用集合的元字符，这样我们可以匹配控制字符，也不需要对常用的字符集做特殊处理。

| 预定义元字符    | 匹配的字符集                                                 |
| --------------- | ------------------------------------------------------------ |
| \t              | 水平制表符                                                   |
| \b              | 空格                                                         |
| \v              | 垂直制表符                                                   |
| \f              | 换页符                                                       |
| \r              | 回车符                                                       |
| \n              | 换行符                                                       |
| `\cA:\cZ`       | 控制字符                                                     |
| `\u0000:\uFFFF` | 十六进制Unicode码                                            |
| `\x00:\xFF`     | 十六进制ASCII码                                              |
| .               | 匹配除换行字符(`\n`、`\r`、`\u2008`和\`u2009`)之外的任意字符 |
| \d              | 匹配任意十进制数字，等价于`[0-9]`                            |
| \D              | 匹配除了十进制数字外的任意字符，等价于`[^0-9]`               |
| \w              | 匹配任何字母、数字和下划线，等价于`[A-Za-z0-9_]`             |
| \W              | 匹配除了字母、数字和下划线之外的字符，等价于`[^A-Za-z0-9_]`  |
| \s              | 匹配任意空白字符（包括空格；制表符、换页符等）               |
| \S              | 匹配除空白字符外的任意字符                                   |
| \b              | 匹配单词边界                                                 |
| \B              | 匹配非单词边界（单词内部）                                   |

### 分组

​	如果对一组术语使用操作符，可以使用圆括号进行分组。例如`/(ab)+/`匹配一个或多个连续的`ab`。当正则的部分使用圆括号分组时具有两种功能，同时也创建捕获。后面详细讨论。

### 或操作符OR

使用竖线(`|`)表示或。例如`/a|b/`可以匹配a或者b，`/(ab)+|(cd)+/`可以匹配一个或多个`ab`或`cd`。

### 反向引用

反向引用可引用正则中定义的捕获。可以把捕获看作待匹配的字符串。反向引用分组中捕获的内容，使用反斜线加上数字表示引用，该数字从1开始，第一个分组捕获的为`\1`，第二个为`\2`，以此类推。

例如正则表达式`/^([dtn])a\1/`匹配的是：以字母d、t或n开头，其后连接字母a，再后连接第一个分组中捕获的内容。这和正则表达式`/^[dtn]a[dtn]/`是不同的。a后面连接的字母不是任意的字母d、t或n，而必须与第一个分组中匹配的字母完全相同。因此`\1`匹配的具体字母是在运行时才能确定的。

## 2 编译正则表达式

处理正则表达式经历多个阶段。

编译阶段发生在正则表达式被创建的时期。执行阶段发生在使用编译之后的正则表达式进行匹配字符串的时期。

在编译过程中，表达式经过`JavaScript`引擎的解析，转换为内部代码。解析和转换的过程发生在正则表达式创建时期（浏览器会进行内部优化处理工作）。

通常来说，浏览器会智能判断使用哪条正则表达式，并缓存该表达式的编译结果。但是我们不指望全部类型的浏览器都能做到这么智能的处理。尤其对于复杂的表达式，我们可以通过预定义（预编译）正则表达式，使得性能得到明显提升。

每个正则表达式都有一个独特的对象表示：每次创建一个正则表达式都会创建一个新的正则表达式对象。这与原始类型（如string、number等）不同，以为每个正则对象永远是独一无二的。

推荐使用预创建或预编译的正则表达式，以便以后重复使用，这对性能的提升不容忽视。

## 3 捕获匹配的片段

### 3.1 执行简单捕获

### 3.2 使用全局表达式进行匹配

### 3.3 捕获的引用

### 3.4 未捕获的分组

